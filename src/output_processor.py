import re
import ast
import logging

logger = logging.getLogger(__name__)

class OutputProcessor:
    """
    A class to process and format code generated by Large Language Models (LLMs).
    
    This class handles formatting code according to language-specific conventions, adding metadata 
    comments, and performing basic syntax verification without executing the code. It’s designed to 
    improve the readability and reliability of LLM-generated code.

    Attributes:
        translated_code (str): The raw code generated by the LLM.
        target_language (str): The programming language of the code (e.g., 'python', 'javascript', 'java').
    """
    
    def __init__(self, translated_code: str, target_language: str):
        """
        Initialize the OutputProcessor with generated code and its target language.

        Args:
            translated_code (str): The raw code string from the LLM.
            target_language (str): The programming language of the code (e.g., 'python', 'javascript').
        """
        self.translated_code = translated_code
        self.target_language = target_language.lower()
        
        # Common formatters for different languages
        self.formatters = {
            "python": self._format_python,
            "javascript": self._format_javascript,
            "java": self._format_java
        }
    
    def format_code(self) -> str:
        """
        Format the code based on the target language’s conventions.

        Applies language-specific formatting rules if available (e.g., spacing, blank lines). If no 
        formatter exists for the target language, returns the code unchanged.

        Returns:
            str: The formatted code string.
        """
        # Apply specific formatter if available
        if self.target_language in self.formatters:
            self.translated_code = self.formatters[self.target_language]()
        
        return self.translated_code
    
    def _format_python(self) -> str:
        """
        Apply Python-specific formatting conventions to the code.

        Rules applied:
        - Replaces tabs with 4 spaces.
        - Removes trailing whitespace.
        - Ensures 2 blank lines before class/function definitions.
        - Limits consecutive blank lines to 2.

        Returns:
            str: The formatted Python code.
        """
        # Convert tabs to spaces
        code = re.sub(r'\t', '    ', self.translated_code)
        
        # Remove trailing whitespace
        code = re.sub(r'[ \t]+$', '', code, flags=re.MULTILINE)
        
        # Ensure two blank lines before class/function definitions
        code = re.sub(r'(\n+)class', r'\n\n\nclass', code)
        code = re.sub(r'(\n+)def', r'\n\n\ndef', code)
        
        # Fix multiple blank lines
        code = re.sub(r'\n{3,}', '\n\n', code)
        
        return code
    
    def _format_javascript(self) -> str:
        """Format JavaScript code."""
        # Basic JS formatting
        return self.translated_code
    
    def _format_java(self) -> str:
        """Format Java code."""
        # Basic Java formatting
        return self.translated_code
    
    def add_comments(self, name: str = "", author: str = "", date: str = "") -> str:
        """
        Add a header comment with metadata to the code.

        The header includes the language, file name, author, and date (if provided), using the appropriate 
        comment style for the target language (e.g., '#' for Python, '//' for JavaScript). Comments are 
        added at the beginning of the code.

        Args:
            name (str, optional): Name of the code file (default: "").
            author (str, optional): Author of the translation (default: "").
            date (str, optional): Date of translation (default: "").

        Returns:
            str: The code with the header comment prepended.
        """
        comment_start = ""
        
        # Set language-specific comment markers
        if self.target_language == "python":
            comment_start = "# "
        elif self.target_language in ["javascript", "java", "c++", "c", "cpp"]:
            comment_start = "// "
        
        # Add header comment
        header = [
            f"{comment_start}Translated code",
            f"{comment_start}Original language: {self.target_language.capitalize()}"
        ]
        
        if name:
            header.append(f"{comment_start}Name: {name}")
        if author:
            header.append(f"{comment_start}Translated by: {author}")
        if date:
            header.append(f"{comment_start}Date: {date}")
            
        header.append(f"{comment_start}{'-' * 50}")
        header.append("")
        
        return "\n".join(header) + self.translated_code
    
    def verify_syntax(self) -> bool:
        """
        Check the syntax of the code without executing it.

        For Python, uses `ast.parse` for full syntax validation. For other languages, performs a basic 
        check for balanced symbols (e.g., braces, brackets). Non-Python checks are limited and may not 
        catch all syntax errors.

        Returns:
            bool: True if syntax is valid (or no specific check exists), False otherwise.
        """
        if not self.translated_code.strip():
            logger.warning("Empty code provided for syntax verification")
            return False
            
        if self.target_language == "python":
            try:
                ast.parse(self.translated_code)
                return True
            except SyntaxError as e:
                line_num = e.lineno if hasattr(e, 'lineno') else 'unknown'
                logger.error(f"Python syntax error at line {line_num}: {str(e)}")
                return False
                
        elif self.target_language in ["javascript", "java", "c++", "c", "cpp"]:
            # For non-Python languages, we can only do basic checks
            # A proper implementation would use language-specific tools
            logger.info(f"Full syntax validation for {self.target_language} not implemented")
            
            # Basic check for balanced braces, brackets, and parentheses
            return self._check_balanced_symbols()
            
        return True
    
    def _check_balanced_symbols(self) -> bool:
        """"
        Verify that braces, brackets, and parentheses in the code are balanced.

        Strips string literals to avoid false positives. This is a basic check and may miss complex cases 
        (e.g., symbols in comments).

        Returns:
            bool: True if symbols are balanced, False otherwise.
        """
        stack = []
        opening = "({["
        closing = ")}]"
        
        # Strip string literals and comments to avoid false positives
        # This is a simplification and not a full parser
        code = re.sub(r'"([^"\\]|\\.)*"', '""', self.translated_code)
        code = re.sub(r"'([^'\\]|\\.)*'", "''", code)
        
        for char in code:
            if char in opening:
                stack.append(char)
            elif char in closing:
                if not stack:
                    return False
                if opening.index(stack.pop()) != closing.index(char):
                    return False
                    
        return len(stack) == 0
