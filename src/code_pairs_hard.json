[
    {
        "title": "Graph Cycle Detection using DFS",
        "cpp_code": "\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool dfs(int node, unordered_map<int, vector<int>>& graph, vector<int>& visited, vector<int>& recStack) {\n    if (!visited[node]) {\n        visited[node] = recStack[node] = 1;\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor] && dfs(neighbor, graph, visited, recStack))\n                return true;\n            else if (recStack[neighbor])\n                return true;\n        }\n    }\n    recStack[node] = 0;\n    return false;\n}\n\nbool hasCycle(unordered_map<int, vector<int>>& graph, int numNodes) {\n    vector<int> visited(numNodes, 0), recStack(numNodes, 0);\n    for (int i = 0; i < numNodes; i++) {\n        if (dfs(i, graph, visited, recStack))\n            return true;\n    }\n    return false;\n}\n\nint main() {\n    unordered_map<int, vector<int>> graph = {{0, {1}}, {1, {2}}, {2, {0}}};\n    cout << (hasCycle(graph, 3) ? \"Cycle detected\" : \"No cycle\") << endl;\n    return 0;\n}",
        "python_code": "\ndef dfs(node, graph, visited, rec_stack):\n    if not visited[node]:\n        visited[node] = rec_stack[node] = True\n        for neighbor in graph.get(node, []):\n            if not visited[neighbor] and dfs(neighbor, graph, visited, rec_stack):\n                return True\n            elif rec_stack[neighbor]:\n                return True\n    rec_stack[node] = False\n    return False\n\ndef has_cycle(graph, num_nodes):\n    visited = [False] * num_nodes\n    rec_stack = [False] * num_nodes\n    for node in range(num_nodes):\n        if dfs(node, graph, visited, rec_stack):\n            return True\n    return False\n\ngraph = {0: [1], 1: [2], 2: [0]}\nprint(\"Cycle detected\" if has_cycle(graph, 3) else \"No cycle\")"
    },
    {
        "title": "Dijkstra's Algorithm for Shortest Path",
        "cpp_code": "\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvector<int> dijkstra(int start, int n, vector<vector<pii>>& graph) {\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    vector<int> dist(n, INT_MAX);\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n\n        for (auto& edge : graph[u]) {\n            int v = edge.first, weight = edge.second;\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return dist;\n}\n\nint main() {\n    vector<vector<pii>> graph = {{{1, 4}, {2, 1}}, {{2, 2}, {3, 5}}, {{3, 1}}, {}};\n    vector<int> distances = dijkstra(0, 4, graph);\n    for (int d : distances) cout << d << \" \";\n    return 0;\n}",
        "python_code": "\nimport heapq\n\ndef dijkstra(start, n, graph):\n    pq = [(0, start)]\n    distances = [float('inf')] * n\n    distances[start] = 0\n\n    while pq:\n        curr_dist, u = heapq.heappop(pq)\n        if curr_dist > distances[u]:\n            continue\n        for v, weight in graph.get(u, []):\n            if distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                heapq.heappush(pq, (distances[v], v))\n    return distances\n\ngraph = {0: [(1, 4), (2, 1)], 1: [(2, 2), (3, 5)], 2: [(3, 1)], 3: []}\nprint(dijkstra(0, 4, graph))"
    }
]