[
    {
        "title": "01 Merge Intervals",
        "cpp_code": "#include <iostream>              // for input and output\n#include <vector>                // for std::vector\n#include <algorithm>             // for std::sort\n\n// Function to merge overlapping intervals\nstd::vector<std::vector<int>> mergeIntervals(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return {};\n\n    // Sort intervals based on the starting point\n    std::sort(intervals.begin(), intervals.end(),\n              [](const std::vector<int>& a, const std::vector<int>& b) {\n                  return a[0] < b[0];\n              });\n\n    std::vector<std::vector<int>> merged;\n    merged.push_back(intervals[0]);\n\n    for (const auto& current : intervals) {\n        auto& lastMerged = merged.back();\n\n        // If the current interval overlaps with the last merged interval, merge them\n        if (current[0] <= lastMerged[1]) {\n            lastMerged[1] = std::max(lastMerged[1], current[1]);\n        } else {\n            // Otherwise, add the current interval as a new merged interval\n            merged.push_back(current);\n        }\n    }\n\n    return merged;\n}\n\n// Example usage\nint main() {\n    std::vector<std::vector<int>> intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    auto result = mergeIntervals(intervals);\n\n    // Print the result\n    for (const auto& interval : result) {\n        std::cout << \"[\" << interval[0] << \", \" << interval[1] << \"] \";\n    }\n    std::cout << std::endl;  // Output: [1, 6] [8, 10] [15, 18]\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n\n    # Sort intervals based on the starting point\n    intervals.sort(key=lambda x: x[0])\n\n    merged = [intervals[0]]\n\n    for current in intervals[1:]:\n        last_merged = merged[-1]\n\n        # If the current interval overlaps with the last merged interval, merge them\n        if current[0] <= last_merged[1]:\n            last_merged[1] = max(last_merged[1], current[1])\n        else:\n            # Otherwise, add the current interval as a new merged interval\n            merged.append(current)\n\n    return merged\n\n# Example usage\nintervals = [[1, 3], [2, 6], [8, 10], [15, 18]]\nresult = merge_intervals(intervals)\n\n# Print the result\nfor interval in result:\n    print(f\"[{interval[0]}, {interval[1]}] \", end=\"\")\nprint()  # Output: [1, 6] [8, 10] [15, 18]",
        "expected_python_code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n\n    # Sort intervals based on the starting point\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = [intervals[0]]  # Start with the first interval\n\n    for current in intervals[1:]:\n        last_merged = merged[-1]\n        \n        # If the current interval overlaps with the last merged interval, merge them\n        if current[0] <= last_merged[1]:\n            last_merged[1] = max(last_merged[1], current[1])\n        else:\n            # Otherwise, add the current interval as a new merged interval\n            merged.append(current)\n    \n    return merged\n\n# Example usage\nintervals = [[1, 3], [2, 6], [8, 10], [15, 18]]\nprint(merge_intervals(intervals))  # Output: [[1, 6], [8, 10], [15, 18]]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "02 Search in Rotated Sorted Array",
        "cpp_code": "#include <iostream>              // for input and output\n#include <vector>                // for std::vector\n\nint searchInRotatedSortedArray(const std::vector<int>& nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            return mid;\n        }\n\n        // Determine which side is sorted\n        if (nums[left] <= nums[mid]) {  // Left side is sorted\n            if (nums[left] <= target && target < nums[mid]) {  // Target is in the sorted side\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {  // Right side is sorted\n            if (nums[mid] < target && target <= nums[right]) {  // Target is in the sorted side\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    return -1;  // Target not found\n}\n\n// Example usage\nint main() {\n    std::vector<int> nums = {4, 5, 6, 7, 0, 1, 2};\n    int target = 0;\n    int index = searchInRotatedSortedArray(nums, target);\n    std::cout << \"Index: \" << index << std::endl;  // Output: Index: 4\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "def searchInRotatedSortedArray(nums, target):\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        # Determine which side is sorted\n        if nums[left] <= nums[mid]:  # Left side is sorted\n            if nums[left] <= target and target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:  # Right side is sorted\n            if nums[mid] < target and target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1  # Target not found\n\n# Example usage\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nindex = searchInRotatedSortedArray(nums, target)\nprint(\"Index:\", index)  # Output: Index: 4",
        "expected_python_code": "def search_in_rotated_sorted_array(nums, target):\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        # Determine which side is sorted\n        if nums[left] <= nums[mid]:  # Left side is sorted\n            if nums[left] <= target < nums[mid]:  # Target is in the sorted side\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:  # Right side is sorted\n            if nums[mid] < target <= nums[right]:  # Target is in the sorted side\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1  # Target not found\n\n# Example usage\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search_in_rotated_sorted_array(nums, target))  # Output: 4",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "03 Count Inversions in Array",
        "cpp_code": "#include <iostream>              // for input and output\n#include <vector>                // for std::vector\n\nint mergeAndCount(std::vector<int>& arr, std::vector<int>& temp_arr, int left, int mid, int right) {\n    int i = left;    // Starting index for left subarray\n    int j = mid + 1; // Starting index for right subarray\n    int k = left;    // Starting index to be sorted\n    int inv_count = 0;\n\n    // Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while (i <= mid && j <= right) {\n        if (arr[i] <= arr[j]) {\n            temp_arr[k++] = arr[i++];\n        } else {\n            temp_arr[k++] = arr[j++];\n            inv_count += (mid - i + 1);\n        }\n    }\n\n    // Copy the remaining elements of left subarray, if any\n    while (i <= mid) {\n        temp_arr[k++] = arr[i++];\n    }\n\n    // Copy the remaining elements of right subarray, if any\n    while (j <= right) {\n        temp_arr[k++] = arr[j++];\n    }\n\n    // Copy the sorted subarray into Original array\n    for (i = left; i <= right; i++) {\n        arr[i] = temp_arr[i];\n    }\n\n    return inv_count;\n}\n\nint mergeSortAndCount(std::vector<int>& arr, std::vector<int>& temp_arr, int left, int right) {\n    int inv_count = 0;\n    if (left < right) {\n        int mid = (left + right) / 2;\n\n        inv_count += mergeSortAndCount(arr, temp_arr, left, mid);\n        inv_count += mergeSortAndCount(arr, temp_arr, mid + 1, right);\n        inv_count += mergeAndCount(arr, temp_arr, left, mid, right);\n    }\n    return inv_count;\n}\n\nint countInversions(std::vector<int>& arr) {\n    std::vector<int> temp_arr(arr.size());\n    return mergeSortAndCount(arr, temp_arr, 0, arr.size() - 1);\n}\n\n// Example usage\nint main() {\n    std::vector<int> arr = {8, 4, 2, 1};\n    std::cout << countInversions(arr) << std::endl;  // Output: 6\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\n\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\n\ndef count_inversions(arr):\n    temp_arr = arr[:]\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)\n\n# Example usage\narr = [8, 4, 2, 1]\nprint(count_inversions(arr))  # Output: 6",
        "expected_python_code": "def count_inversions(arr):\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid-i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right)//2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)\n\n# Example usage\narr = [8, 4, 2, 1]\nprint(count_inversions(arr))  # Output: 6",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "04 Find the Missing Number",
        "cpp_code": "#include <iostream>              // for input and output\n#include <vector>                // for std::vector\n\nint findMissingNumber(const std::vector<int>& arr) {\n    int n = arr.size();\n    int expected_sum = (n * (n + 1)) / 2;\n    int actual_sum = 0;\n\n    for (int num : arr) {\n        actual_sum += num;\n    }\n\n    return expected_sum - actual_sum;\n}\n\n// Example usage\nint main() {\n    std::vector<int> arr = {3, 0, 1};\n    std::cout << findMissingNumber(arr) << std::endl;  // Output: 2\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "def find_missing_number(arr):\n    n = len(arr)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(arr)\n\n    return expected_sum - actual_sum\n\n# Example usage\narr = [3, 0, 1]\nprint(find_missing_number(arr))  # Output: 2",
        "expected_python_code": "def find_missing_number(arr):\n    n = len(arr)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(arr)\n    return expected_sum - actual_sum\n\n# Example usage\narr = [3, 0, 1]\nprint(find_missing_number(arr))  # Output: 2",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "05 Longest Increasing Subsequence",
        "cpp_code": "#include <iostream>              // for input and output\n#include <vector>                // for std::vector\n#include <algorithm>             // for std::max\n\nint lengthOfLIS(const std::vector<int>& nums) {\n    if (nums.empty()) return 0;\n\n    int n = nums.size();\n    std::vector<int> dp(n, 1);\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                dp[i] = std::max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n\n    return *std::max_element(dp.begin(), dp.end());\n}\n\n// Example usage\nint main() {\n    std::vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};\n    std::cout << lengthOfLIS(nums) << std::endl;  // Output: 4\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "def length_of_lis(nums):\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n# Example usage\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(length_of_lis(nums))  # Output: 4",
        "expected_python_code": "def length_of_lis(nums):\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n# Example usage\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(length_of_lis(nums))  # Output: 4",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "06 Minimum Window Substring",
        "cpp_code": "#include <iostream>              // for input and output\n#include <unordered_map>         // for std::unordered_map\n#include <climits>               // for INT_MAX\n\nstd::string minWindowSubstring(const std::string& S, const std::string& T) {\n    if (S.empty() || T.empty()) return \"\";\n    \n    std::unordered_map<char, int> target_count;\n    std::unordered_map<char, int> window_count;\n    \n    for (char c : T) {\n        target_count[c]++;\n    }\n    \n    int required = target_count.size();\n    int formed = 0;\n    \n    int l = 0, r = 0;\n    int min_len = INT_MAX;\n    std::string min_window;\n    \n    while (r < S.size()) {\n        char c = S[r];\n        window_count[c]++;\n        \n        if (target_count.find(c) != target_count.end() && window_count[c] == target_count[c]) {\n            formed++;\n        }\n        \n        while (l <= r && formed == required) {\n            c = S[l];\n            \n            if (r - l + 1 < min_len) {\n                min_len = r - l + 1;\n                min_window = S.substr(l, min_len);\n            }\n            \n            window_count[c]--;\n            if (target_count.find(c) != target_count.end() && window_count[c] < target_count[c]) {\n                formed--;\n            }\n            \n            l++;\n        }\n        \n        r++;\n    }\n    \n    return min_window;\n}\n\n// Example usage\nint main() {\n    std::string S = \"ADOBECODEBANC\";\n    std::string T = \"ABC\";\n    std::cout << minWindowSubstring(S, T) << std::endl;  // Output: \"BANC\"\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "from collections import Counter\n\ndef min_window_substring(S, T):\n    if not S or not T:\n        return \"\"\n\n    target_count = Counter(T)\n    window_count = Counter()\n    required = len(target_count)\n    formed = 0\n\n    l, r = 0, 0\n    min_len = float('inf')\n    min_window = \"\"\n\n    while r < len(S):\n        char = S[r]\n        window_count[char] += 1\n\n        if char in target_count and window_count[char] == target_count[char]:\n            formed += 1\n\n        while l <= r and formed == required:\n            char = S[l]\n\n            if r - l + 1 < min_len:\n                min_len = r - l + 1\n                min_window = S[l:r+1]\n\n            window_count[char] -= 1\n            if char in target_count and window_count[char] < target_count[char]:\n                formed -= 1\n\n            l += 1\n\n        r += 1\n\n    return min_window\n\n# Example usage\nif __name__ == \"__main__\":\n    S = \"ADOBECODEBANC\"\n    T = \"ABC\"\n    print(min_window_substring(S, T))  # Output: \"BANC\"",
        "expected_python_code": "from collections import Counter, defaultdict\n\ndef min_window_substring(S, T):\n    if not S or not T:\n        return \"\"\n    \n    target_count = Counter(T)\n    window_count = defaultdict(int)\n    required = len(target_count)\n    formed = 0\n    \n    l, r = 0, 0\n    min_len = float('inf')\n    min_window = \"\"\n    \n    while r < len(S):\n        char = S[r]\n        window_count[char] += 1\n        \n        if char in target_count and window_count[char] == target_count[char]:\n            formed += 1\n        \n        while l <= r and formed == required:\n            char = S[l]\n            \n            if r - l + 1 < min_len:\n                min_len = r - l + 1\n                min_window = S[l:r+1]\n            \n            window_count[char] -= 1\n            if char in target_count and window_count[char] < target_count[char]:\n                formed -= 1\n            \n            l += 1\n        \n        r += 1\n    \n    return min_window\n\n# Example usage\nS = \"ADOBECODEBANC\"\nT = \"ABC\"\nprint(min_window_substring(S, T))  # Output: \"BANC\"",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "07 Graph Coloring Problem",
        "cpp_code": "#include <iostream>               // for input and output\n#include <vector>                 // for std::vector\n#include <unordered_map>          // for std::unordered_map\n\nbool isValid(const std::unordered_map<int, std::vector<int>>& graph, const std::vector<int>& colors, int vertex, int color) {\n    for (int neighbor : graph.at(vertex)) {\n        if (colors[neighbor] == color) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool graphColoringUtil(const std::unordered_map<int, std::vector<int>>& graph, std::vector<int>& colors, int vertex, int M) {\n    if (vertex == graph.size()) {\n        return true;\n    }\n    \n    for (int color = 1; color <= M; ++color) {\n        if (isValid(graph, colors, vertex, color)) {\n            colors[vertex] = color;\n            if (graphColoringUtil(graph, colors, vertex + 1, M)) {\n                return true;\n            }\n            colors[vertex] = -1;  // Backtrack\n        }\n    }\n    \n    return false;\n}\n\nbool graphColoring(const std::unordered_map<int, std::vector<int>>& graph, int M) {\n    std::vector<int> colors(graph.size(), -1);\n    return graphColoringUtil(graph, colors, 0, M);\n}\n\n// Example usage\nint main() {\n    std::unordered_map<int, std::vector<int>> graph = {\n        {0, {1, 2}},\n        {1, {0, 2}},\n        {2, {0, 1}}\n    };\n    int M = 2;\n    std::cout << (graphColoring(graph, M) ? \"True\" : \"False\") << std::endl;  // Output: True\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "from typing import List, Dict\n\ndef is_valid(graph: Dict[int, List[int]], colors: List[int], vertex: int, color: int) -> bool:\n    for neighbor in graph[vertex]:\n        if colors[neighbor] == color:\n            return False\n    return True\n\ndef graph_coloring_util(graph: Dict[int, List[int]], colors: List[int], vertex: int, M: int) -> bool:\n    if vertex == len(graph):\n        return True\n\n    for color in range(1, M + 1):\n        if is_valid(graph, colors, vertex, color):\n            colors[vertex] = color\n            if graph_coloring_util(graph, colors, vertex + 1, M):\n                return True\n            colors[vertex] = -1  # Backtrack\n\n    return False\n\ndef graph_coloring(graph: Dict[int, List[int]], M: int) -> bool:\n    colors = [-1] * len(graph)\n    return graph_coloring_util(graph, colors, 0, M)\n\n# Example usage\ngraph = {\n    0: [1, 2],\n    1: [0, 2],\n    2: [0, 1]\n}\nM = 2\nprint(\"True\" if graph_coloring(graph, M) else \"False\")  # Output: True",
        "expected_python_code": "def is_valid(graph, colors, vertex, color):\n    for neighbor in graph[vertex]:\n        if colors[neighbor] == color:\n            return False\n    return True\n\ndef graph_coloring_util(graph, colors, vertex, M):\n    if vertex == len(graph):\n        return True\n    \n    for color in range(1, M + 1):\n        if is_valid(graph, colors, vertex, color):\n            colors[vertex] = color\n            if graph_coloring_util(graph, colors, vertex + 1, M):\n                return True\n            colors[vertex] = -1  # Backtrack\n    \n    return False\n\ndef graph_coloring(graph, M):\n    colors = [-1] * len(graph)\n    return graph_coloring_util(graph, colors, 0, M)\n\n# Example usage\ngraph = {0: [1, 2], 1: [0, 2], 2: [0, 1]}\nM = 2\nprint(graph_coloring(graph, M))  # Output: True",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "08 Topological Sort Kahn Algorithm",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nstd::vector<int> topologicalSortKahn(const std::unordered_map<int, std::vector<int>>& graph) {\n    std::unordered_map<int, int> inDegree;\n    for (const auto& pair : graph) {\n        inDegree[pair.first] = 0;\n    }\n    for (const auto& pair : graph) {\n        for (int neighbor : pair.second) {\n            inDegree[neighbor]++;\n        }\n    }\n\n    std::queue<int> queue;\n    for (const auto& pair : inDegree) {\n        if (pair.second == 0) {\n            queue.push(pair.first);\n        }\n    }\n\n    std::vector<int> topologicalOrder;\n    while (!queue.empty()) {\n        int node = queue.front();\n        queue.pop();\n        topologicalOrder.push_back(node);\n\n        for (int neighbor : graph.at(node)) {\n            inDegree[neighbor]--;\n            if (inDegree[neighbor] == 0) {\n                queue.push(neighbor);\n            }\n        }\n    }\n\n    return topologicalOrder;\n}\n\n// Example usage\nint main() {\n    std::unordered_map<int, std::vector<int>> graph = {\n        {5, {2, 0}},\n        {4, {0, 1}},\n        {2, {3}},\n        {3, {1}}\n    };\n    std::vector<int> result = topologicalSortKahn(graph);\n    for (int node : result) {\n        std::cout << node << \" \";\n    }\n    std::cout << std::endl;  // Output: 4 5 2 3 1 0\n\n    return 0;\n}",
        "translated_python_code": "from collections import defaultdict, deque\n\ndef topological_sort_kahn(graph):\n    in_degree = defaultdict(int)\n    for node, neighbors in graph.items():\n        in_degree[node] = 0\n    for node, neighbors in graph.items():\n        for neighbor in neighbors:\n            in_degree[neighbor] += 1\n\n    queue = deque()\n    for node, degree in in_degree.items():\n        if degree == 0:\n            queue.append(node)\n\n    topological_order = []\n    while queue:\n        node = queue.popleft()\n        topological_order.append(node)\n\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    return topological_order\n\n# Example usage\ngraph = {\n    5: [2, 0],\n    4: [0, 1],\n    2: [3],\n    3: [1]\n}\nresult = topological_sort_kahn(graph)\nprint(\" \".join(map(str, result)))  # Output: 4 5 2 3 1 0",
        "expected_python_code": "from collections import deque, defaultdict\n\ndef topological_sort_kahn(graph):\n    # Step 1: Calculate in-degrees\n    in_degree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n    \n    # Step 2: Initialize the queue with nodes having 0 in-degree\n    queue = deque([node for node in in_degree if in_degree[node] == 0])\n    topological_order = []\n    \n    # Step 3: Process nodes in the queue\n    while queue:\n        node = queue.popleft()\n        topological_order.append(node)\n        \n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if topological_order contains all nodes\n    if len(topological_order) == len(graph):\n        return topological_order\n    else:\n        return []  # Graph has a cycle or is not a DAG\n\n# Example usage\ngraph = {5: [2, 0], 4: [0, 1], 2: [3], 3: [1]}\nprint(topological_sort_kahn(graph))  # Output: [4, 5, 2, 3, 1, 0]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "09 Topological Sort DFS Based Approach",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <stack>\n\nvoid dfs(int node, const std::unordered_map<int, std::vector<int>>& graph, std::unordered_set<int>& visited, std::stack<int>& Stack) {\n    visited.insert(node);\n    for (int neighbor : graph.at(node)) {\n        if (visited.find(neighbor) == visited.end()) {\n            dfs(neighbor, graph, visited, Stack);\n        }\n    }\n    Stack.push(node);\n}\n\nstd::vector<int> topologicalSortDFS(const std::unordered_map<int, std::vector<int>>& graph) {\n    std::unordered_set<int> visited;\n    std::stack<int> Stack;\n    \n    for (const auto& pair : graph) {\n        if (visited.find(pair.first) == visited.end()) {\n            dfs(pair.first, graph, visited, Stack);\n        }\n    }\n    \n    std::vector<int> topologicalOrder;\n    while (!Stack.empty()) {\n        topologicalOrder.push_back(Stack.top());\n        Stack.pop();\n    }\n    \n    return topologicalOrder;\n}\n\n// Example usage\nint main() {\n    std::unordered_map<int, std::vector<int>> graph = {\n        {5, {2, 0}},\n        {4, {0, 1}},\n        {2, {3}},\n        {3, {1}}\n    };\n    std::vector<int> result = topologicalSortDFS(graph);\n    for (int node : result) {\n        std::cout << node << \" \";\n    }\n    std::cout << std::endl;  // Output: 4 5 2 3 1 0\n\n    return 0;\n}",
        "translated_python_code": "from collections import defaultdict, deque\n\ndef dfs(node, graph, visited, stack):\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs(neighbor, graph, visited, stack)\n    stack.appendleft(node)\n\ndef topological_sort_dfs(graph):\n    visited = set()\n    stack = deque()\n\n    for node in graph:\n        if node not in visited:\n            dfs(node, graph, visited, stack)\n\n    topological_order = []\n    while stack:\n        topological_order.append(stack.popleft())\n\n    return topological_order\n\n# Example usage\ngraph = {\n    5: [2, 0],\n    4: [0, 1],\n    2: [3],\n    3: [1]\n}\nresult = topological_sort_dfs(graph)\nprint(\" \".join(map(str, result)))  # Output: 4 5 2 3 1 0",
        "expected_python_code": "def topological_sort_dfs(graph):\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n        topological_order.append(node)\n    \n    visited = set()\n    topological_order = []\n    \n    # Visit all nodes\n    for node in graph:\n        if node not in visited:\n            dfs(node)\n    \n    return topological_order[::-1]  # Reverse to get the correct order\n\n# Example usage\ngraph = {5: [2, 0], 4: [0, 1], 2: [3], 3: [1]}\nprint(topological_sort_dfs(graph))  # Output: [4, 5, 2, 3, 1, 0]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "10 Matrix Chain Multiplication",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nint matrixChainMultiplication(const std::vector<int>& dimensions) {\n    int n = dimensions.size() - 1;\n    std::vector<std::vector<int>> m(n, std::vector<int>(n, 0));\n    \n    // l is the chain length\n    for (int l = 2; l <= n; ++l) {  // l ranges from 2 to n\n        for (int i = 0; i < n - l + 1; ++i) {\n            int j = i + l - 1;\n            m[i][j] = INT_MAX;\n            for (int k = i; k < j; ++k) {\n                int q = m[i][k] + m[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1];\n                if (q < m[i][j]) {\n                    m[i][j] = q;\n                }\n            }\n        }\n    }\n    \n    return m[0][n-1];\n}\n\n// Example usage\nint main() {\n    std::vector<int> dimensions = {10, 20, 30, 40, 30};\n    std::cout << \"Minimum number of multiplications: \" << matrixChainMultiplication(dimensions) << std::endl;  // Output: 30000\n    return 0;\n}",
        "translated_python_code": "def matrix_chain_multiplication(dimensions):\n    n = len(dimensions) - 1\n    m = [[float('inf')] * n for _ in range(n)]\n\n    # l is the chain length\n    for l in range(2, n + 1):  # l ranges from 2 to n\n        for i in range(n - l + 1):\n            j = i + l - 1\n            m[i][j] = float('inf')\n            for k in range(i, j):\n                q = m[i][k] + m[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1]\n                if q < m[i][j]:\n                    m[i][j] = q\n\n    return m[0][n-1]\n\n# Example usage\ndimensions = [10, 20, 30, 40, 30]\nprint(\"Minimum number of multiplications:\", matrix_chain_multiplication(dimensions))  # Output: 30000",
        "expected_python_code": "def matrix_chain_multiplication(dimensions):\n    n = len(dimensions) - 1\n    # m[i][j] will be the minimum number of multiplications needed to compute the product of matrices from i to j\n    m = [[0] * n for _ in range(n)]\n    \n    # l is the chain length\n    for l in range(2, n+1):  # l ranges from 2 to n\n        for i in range(n - l + 1):\n            j = i + l - 1\n            m[i][j] = float('inf')\n            for k in range(i, j):\n                q = m[i][k] + m[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1]\n                if q < m[i][j]:\n                    m[i][j] = q\n    \n    return m[0][n-1]\n\n# Example usage\ndimensions = [10, 20, 30, 40, 30]\nprint(\"Minimum number of multiplications:\", matrix_chain_multiplication(dimensions))  # Output: 30000",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "11 Travelling Salesman Problem",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nint tsp(const std::vector<std::vector<int>>& distance) {\n    int n = distance.size();\n    std::vector<std::vector<int>> dp(1 << n, std::vector<int>(n, INT_MAX));\n    dp[1][0] = 0;  // Start at city 0\n\n    for (int mask = 1; mask < (1 << n); ++mask) {\n        for (int i = 0; i < n; ++i) {\n            if (mask & (1 << i)) {\n                for (int j = 0; j < n; ++j) {\n                    if (!(mask & (1 << j))) {\n                        int new_mask = mask | (1 << j);\n                        dp[new_mask][j] = std::min(dp[new_mask][j], dp[mask][i] + distance[i][j]);\n                    }\n                }\n            }\n        }\n    }\n\n    // Compute the minimum cost to return to the starting city (0)\n    int result = INT_MAX;\n    for (int i = 1; i < n; ++i) {\n        result = std::min(result, dp[(1 << n) - 1][i] + distance[i][0]);\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<std::vector<int>> distance_matrix = {{0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};\n    std::cout << \"Minimum cost: \" << tsp(distance_matrix) << std::endl;  // Output: 80\n    return 0;\n}",
        "translated_python_code": "def tsp(distance):\n    n = len(distance)\n    dp = [[float('inf')] * n for _ in range(1 << n)]\n    dp[1][0] = 0  # Start at city 0\n\n    for mask in range(1, 1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                for j in range(n):\n                    if not (mask & (1 << j)):\n                        new_mask = mask | (1 << j)\n                        dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + distance[i][j])\n\n    # Compute the minimum cost to return to the starting city (0)\n    result = float('inf')\n    for i in range(1, n):\n        result = min(result, dp[(1 << n) - 1][i] + distance[i][0])\n\n    return result\n\nif __name__ == \"__main__\":\n    distance_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\n    print(\"Minimum cost:\", tsp(distance_matrix))  # Output: 80",
        "expected_python_code": "def tsp(distance):\n    n = len(distance)\n    # Initialize the dp array with infinity\n    dp = [[float('inf')] * n for _ in range(1 << n)]\n    dp[1][0] = 0  # Start at city 0\n\n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                for j in range(n):\n                    if mask & (1 << j) == 0:\n                        new_mask = mask | (1 << j)\n                        dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + distance[i][j])\n\n    # Compute the minimum cost to return to the starting city (0)\n    result = min(dp[(1 << n) - 1][i] + distance[i][0] for i in range(1, n))\n    \n    return result\n\n# Example usage\ndistance_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\nprint(\"Minimum cost:\", tsp(distance_matrix))  # Output: 80",
        "match_with_reference": false,
        "success": true,
        "error": null
    }
]