[
    {
        "title": "01 Binary Tree Inorder Traversal",
        "cpp_code": "#include <iostream>     // include the iostream library for input and output\n#include <vector>       // include the vector library for std::vector\n#include <stack>        // include the stack library for std::stack\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int value;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : value(x), left(nullptr), right(nullptr) {}\n};\n\nstd::vector<int> inorder_traversal(TreeNode* root) {\n    std::vector<int> result;\n    std::stack<TreeNode*> stack;\n    TreeNode* current = root;\n    \n    while (current != nullptr || !stack.empty()) {\n        while (current != nullptr) {\n            stack.push(current);\n            current = current->left;\n        }\n        \n        current = stack.top();\n        stack.pop();\n        result.push_back(current->value);\n        current = current->right;\n    }\n    \n    return result;\n}\n\n// Helper function to build a tree from a list\nTreeNode* build_tree_from_list(const std::vector<int>& values) {\n    if (values.empty()) return nullptr;\n    \n    std::vector<TreeNode*> nodes;\n    for (int val : values) {\n        nodes.push_back(val == -1 ? nullptr : new TreeNode(val));\n    }\n    \n    TreeNode* root = nodes[0];\n    std::queue<TreeNode*> q;\n    q.push(root);\n    int i = 1;\n    \n    while (i < values.size()) {\n        TreeNode* node = q.front();\n        q.pop();\n        \n        if (node) {\n            node->left = nodes[i++];\n            if (node->left) q.push(node->left);\n            \n            if (i < values.size()) {\n                node->right = nodes[i++];\n                if (node->right) q.push(node->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\nint main() {\n    std::vector<int> input_list = {1, -1, 2, 3}; // Use -1 for None\n    TreeNode* root = build_tree_from_list(input_list);\n    \n    std::vector<int> result = inorder_traversal(root);\n    std::cout << \"Inorder traversal: \";\n    for (int val : result) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl; // Output: Inorder traversal: 1 3 2\n    \n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "# include the iostream library for input and output\nimport sys      # include the vector library for std::vector\nimport typing   # include the stack library for std::stack\nfrom typing import List, Optional\n\n# Definition for a binary tree node.\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef inorder_traversal(root: Optional[TreeNode]) -> List[int]:\n    result = []\n    stack = []\n    current = root\n\n    while current is not None or len(stack) != 0:\n        while current is not None:\n            stack.append(current)\n            current = current.left\n\n        current = stack.pop()\n        result.append(current.val)\n        current = current.right\n\n    return result\n\n# Helper function to build a tree from a list\n\ndef build_tree_from_list(values: List[int]) -> Optional[TreeNode]:\n    if not values:\n        return None\n\n    nodes = [None if val == -1 else TreeNode(val) for val in values]\n\n    root = nodes[0]\n    stack = [root]\n    i = 1\n\n    while i < len(values):\n        node = stack[0]\n        stack = stack[1:]\n\n        if node:\n            node.left = nodes[i]\n            if node.left:\n                stack.append(node.left)\n\n            if i + 1 < len(values):\n                node.right = nodes[i+1]\n                if node.right:\n                    stack.append(node.right)\n            i += 2\n\n    return root\n\nif __name__ == \"__main__\":\n    input_list = [1, -1, 2, 3]  # Use -1 for None\n    root = build_tree_from_list(input_list)\n\n    result = inorder_traversal(root)\n    print(\"Inorder traversal:\", \" \".join(map(str,result)))\n    # Output: Inorder traversal: 1 3 2",
        "expected_python_code": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef inorder_traversal(root):\n    result = []\n    \n    def traverse(node):\n        if node:\n            traverse(node.left)  # Traverse the left subtree\n            result.append(node.value)  # Visit the root\n            traverse(node.right)  # Traverse the right subtree\n    \n    traverse(root)\n    return result\n\n# Helper function to build a tree from a list\ndef build_tree_from_list(values):\n    if not values:\n        return None\n    \n    nodes = [None if val is None else TreeNode(val) for val in values]\n    kids = nodes[::-1]\n    root = kids.pop()\n    \n    for node in nodes:\n        if node:\n            if kids:\n                node.left = kids.pop()\n            if kids:\n                node.right = kids.pop()\n    \n    return root\n\n# Test the function with the input [1, None, 2, 3]\ninput_list = [1, None, 2, 3]\nroot = build_tree_from_list(input_list)\nprint(inorder_traversal(root))  # Output: [1, 3, 2]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "02 Graph Cycle Detection",
        "cpp_code": "#include <iostream>            // include the iostream library for input and output\n#include <unordered_map>       // include the unordered_map library for std::unordered_map\n#include <unordered_set>       // include the unordered_set library for std::unordered_set\n#include <vector>              // include the vector library for std::vector\n\nusing namespace std;\n\n// Helper function for DFS\nbool dfs(const string& node, unordered_map<string, vector<string>>& graph, \n         unordered_set<string>& visited, unordered_set<string>& recursion_stack) {\n    visited.insert(node);\n    recursion_stack.insert(node);\n    \n    for (const string& neighbor : graph[node]) {\n        if (recursion_stack.find(neighbor) != recursion_stack.end()) {\n            return true;  // Found a cycle\n        }\n        if (visited.find(neighbor) == visited.end()) {\n            if (dfs(neighbor, graph, visited, recursion_stack)) {\n                return true;\n            }\n        }\n    }\n    \n    recursion_stack.erase(node);\n    return false;\n}\n\n// Function to check if the graph contains a cycle\nbool has_cycle(unordered_map<string, vector<string>>& graph) {\n    unordered_set<string> visited;\n    unordered_set<string> recursion_stack;\n    \n    for (const auto& pair : graph) {\n        if (visited.find(pair.first) == visited.end()) {\n            if (dfs(pair.first, graph, visited, recursion_stack)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    unordered_map<string, vector<string>> graph = {\n        {\"A\", {\"B\"}},\n        {\"B\", {\"C\"}},\n        {\"C\", {\"A\"}}\n    };\n    \n    cout << (has_cycle(graph) ? \"True\" : \"False\") << endl;  // Output: True\n    \n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "# include the iostream library for input and output\nimport unordered_map as umap  # include the unordered_map library for std::unordered<\uff5cbegin\u2581of\u2581sentence\uff5c>\nimport unordered_set as uset  # include the unordered_set library for std::unordere<s\nimport vector  # include the vector library for std::vector\n\n# Helper function for DFS\n\ndef dfs(node, graph, visited, recursion_stack):\n    visited.add(node)\n    recursion_stack.add(node)\n\n    for neighbor in graph[node]:\n        if neighbor in recursion_stack:\n            return True  # Found a cycle\n\n        if neighbor not in visited:\n            if dfs(neighbor, graph, visited, recursion_stack):\n                return True\n\n    recursion_stack.remove(node)\n    return False\n\n# Function to check if the graph contains a cycle\n\ndef has_cycle(graph):\n    visited = set()\n    recursion_stack = set()\n\n    for pair in graph:\n        node = pair[0]\n        if node not in visited:\n            if dfs(node, graph, visited, recursion_stack):\n                return True\n\n    return False\n\ngraph = {\n    \"A\": [\"B\"],\n    \"B\": [\"C\"],\n    \"C\": [\"A\"]\n}\n\nprint('True' if has_cycle(graph) else 'False')   # Output: True",
        "expected_python_code": "def has_cycle(graph):\n    def dfs(node, visited, recursion_stack):\n        visited.add(node)\n        recursion_stack.add(node)\n        \n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                if dfs(neighbor, visited, recursion_stack):\n                    return True\n            elif neighbor in recursion_stack:\n                return True\n        \n        recursion_stack.remove(node)\n        return False\n\n    visited = set()\n    recursion_stack = set()\n    \n    for node in graph:\n        if node not in visited:\n            if dfs(node, visited, recursion_stack):\n                return True\n    return False\n\n# Test the function with the input graph\ngraph = {'A': ['B'], 'B': ['C'], 'C': ['A']}\nprint(has_cycle(graph))  # Output: True",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "03 Max Heap Implementation",
        "cpp_code": "#include <iostream>        // include the iostream library for input and output\n#include <vector>          // include the vector library for std::vector>\n#include <stdexcept>       // include the stdexcept library for std::out_of_range exception\n\nclass MaxHeap {\npublic:\n    MaxHeap() {}\n\n    void insert(int value) {\n        heap.push_back(value);\n        heapify_up(heap.size() - 1);\n    }\n\n    int extract_max() {\n        if (heap.empty()) {\n            throw std::out_of_range(\"Heap is empty\");\n        }\n        int max_value = heap[0];\n        heap[0] = heap.back();\n        heap.pop_back();\n        if (!heap.empty()) {\n            heapify_down(0);\n        }\n        return max_value;\n    }\n\nprivate:\n    std::vector<int> heap;\n\n    void heapify_up(int index) {\n        int parent_index = (index - 1) / 2;\n        if (index > 0 && heap[index] > heap[parent_index]) {\n            std::swap(heap[index], heap[parent_index]);\n            heapify_up(parent_index);\n        }\n    }\n\n    void heapify_down(int index) {\n        int left_child_index = 2 * index + 1;\n        int right_child_index = 2 * index + 2;\n        int largest = index;\n        \n        if (left_child_index < heap.size() && heap[left_child_index] > heap[largest]) {\n            largest = left_child_index;\n        }\n        \n        if (right_child_index < heap.size() && heap[right_child_index] > heap[largest]) {\n            largest = right_child_index;\n        }\n        \n        if (largest != index) {\n            std::swap(heap[index], heap[largest]);\n            heapify_down(largest);\n        }\n    }\n};\n\nint main() {\n    MaxHeap max_heap;\n    max_heap.insert(3);\n    max_heap.insert(2);\n    max_heap.insert(15);\n    std::cout << max_heap.extract_max() << std::endl;  // Output: 15\n    \n    return 0;  // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "class MaxHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n        self._heapify_up(len(self.heap) - 1)\n\n    def extract_max(self):\n        if not self.heap:\n            raise IndexError(\"Heap is empty\")\n        max_value = self.heap[0]\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        if self.heap:\n            self._heapify_down(0)\n        return max_value\n\n    def _heapify_up(self, index):\n        parent_index = (index - 1) // 2\n        if index > 0 and self.heap[index] > self.heap[parent_index]:\n            self._swap(index, parent_index)\n            self._heapify_up(parent_index)\n\n    def _heapify_down(self, index):\n        left_child_index = 2 * index + 1\n        right_child_index = 2 * index + 2\n        largest = index\n\n        if (left_child_index < len(self.heap) and\n            self.heap[left_child_index] > self.heap[largest]):\n            largest = left_child_index\n\n        if (right_child_index < len(self.heap) and\n            self.heap[right_child_index] > self.heap[largest]):\n            largest = right_child_index\n\n        if largest != index:\n            self._swap(index, largest)\n            self._heapify_down(largest)\n\n    def _swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n\ndef main():\n    max_heap = MaxHeap()\n    max_heap.insert(3)\n    max_heap.insert(2)\n    max_heap.insert(15)\n    print(max_heap.extract_max())  # Output: 15\n\nif __name__ == \"__main__\":\n    main()",
        "expected_python_code": "class MaxHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        # Add the new value at the end of the heap\n        self.heap.append(value)\n        self._heapify_up(len(self.heap) - 1)\n\n    def extract_max(self):\n        if not self.heap:\n            raise IndexError(\"Heap is empty\")\n        # The max value is at the root\n        max_value = self.heap[0]\n        # Move the last value to the root and heapify down\n        self.heap[0] = self.heap.pop()\n        if self.heap:\n            self._heapify_down(0)\n        return max_value\n\n    def _heapify_up(self, index):\n        # Move the element at index up to maintain the heap property\n        parent_index = (index - 1) // 2\n        if index > 0 and self.heap[index] > self.heap[parent_index]:\n            self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n            self._heapify_up(parent_index)\n\n    def _heapify_down(self, index):\n        # Move the element at index down to maintain the heap property\n        left_child_index = 2 * index + 1\n        right_child_index = 2 * index + 2\n        largest = index\n        \n        if (left_child_index < len(self.heap) and\n            self.heap[left_child_index] > self.heap[largest]):\n            largest = left_child_index\n        \n        if (right_child_index < len(self.heap) and\n            self.heap[right_child_index] > self.heap[largest]):\n            largest = right_child_index\n        \n        if largest != index:\n            self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]\n            self._heapify_down(largest)\n\n# Test the MaxHeap\nmax_heap = MaxHeap()\nmax_heap.insert(3)\nmax_heap.insert(2)\nmax_heap.insert(15)\nprint(max_heap.extract_max())  # Output: 15",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "04 Inorder Successor in BST",
        "cpp_code": "#include <iostream>            // include the iostream library for input and output\n#include <vector>              // include the vector library for std::vector>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int key;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : key(x), left(nullptr), right(nullptr) {}\n};\n\n// Helper function to find the minimum value node in a subtree\nTreeNode* min_value_node(TreeNode* node) {\n    TreeNode* current = node;\n    while (current && current->left != nullptr) {\n        current = current->left;\n    }\n    return current;\n}\n\n// Function to find the inorder successor of a given node\nTreeNode* find_inorder_successor(TreeNode* root, TreeNode* node) {\n    if (node->right != nullptr) {\n        return min_value_node(node->right);\n    }\n    \n    TreeNode* successor = nullptr;\n    TreeNode* ancestor = root;\n    \n    while (ancestor != node) {\n        if (node->key < ancestor->key) {\n            successor = ancestor;\n            ancestor = ancestor->left;\n        } else {\n            ancestor = ancestor->right;\n        }\n    }\n    \n    return successor;\n}\n\n// Helper function to build a tree from a list\nTreeNode* build_tree_from_list(const std::vector<int>& values, int index = 0) {\n    if (index >= values.size() || values[index] == -1) {\n        return nullptr;\n    }\n    \n    TreeNode* node = new TreeNode(values[index]);\n    node->left = build_tree_from_list(values, 2 * index + 1);\n    node->right = build_tree_from_list(values, 2 * index + 2);\n    \n    return node;\n}\n\nint main() {\n    std::vector<int> input_list = {20, 8, 22, 4, 12, -1, -1, -1, -1, 10, 14}; // Use -1 for None\n    TreeNode* root = build_tree_from_list(input_list);\n    TreeNode* node = root; // Assuming the node with key 8 is the target\n    while (node && node->key != 8) {\n        if (8 < node->key) {\n            node = node->left;\n        } else {\n            node = node->right;\n        }\n    }\n    \n    TreeNode* successor = find_inorder_successor(root, node);\n    std::cout << (successor ? successor->key : -1) << std::endl;  // Output: 10\n    \n    return 0;  // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "class TreeNode:\n    def __init__(self, x):\n        self.key = x\n        self.left = None\n        self.right = None\n\ndef min_value_node(node):\n    current = node\n    while current and current.left is not None:\n        current = current.left\n    return current\n\ndef find_inorder_successor(root, node):\n    if node.right is not None:\n        return min_value_node(node.right)\n\n    successor = None\n    ancestor = root\n\n    while ancestor != node:\n        if node.key < ancestor.key:\n            successor = ancestor\n            ancestor = ancestor.left\n        else:\n            ancestor = ancestor.right\n\n    return successor\n\ndef build_tree_from_list(values, index = 0):\n    if index >= len(values) or values[index] == -1:\n        return None\n\n    node = TreeNode(values[index])\n    node.left = build_tree_from_list(values, 2 * index + 1)\n    node.right = build_tree_from_list(values, 2 * index + 2)\n\n    return node\n\ndef main():\n    input_list = [20, 8, 22, 4, 12, -1, -1, -1, -1, 10, 14]\n    root = build_tree_from_list(input_list)\n\n    node = root\n    while node and node.key != 8:\n        if 8 < node.key:\n            node = node.left\n        else:\n            node = node.right\n\n    successor = find_inorder_successor(root, node)\n\n    print(successor.key if successor else -1)\n\nif __name<\uff5cbegin\u2581of\u2581sentence\uff5c>__ == \"__main__\":\n    main()",
        "expected_python_code": "class TreeNode:\n    def __init__(self, key, left=None, right=None):\n        self.key = key\n        self.left = left\n        self.right = right\n\ndef inorder_successor(root, n):\n    successor = None\n    \n    while root:\n        if n.key < root.key:\n            successor = root\n            root = root.left\n        else:\n            root = root.right\n    \n    return successor\n\ndef min_value_node(node):\n    current = node\n    while current.left:\n        current = current.left\n    return current\n\ndef find_inorder_successor(root, key):\n    # Find the node\n    node = root\n    while node and node.key != key:\n        if key < node.key:\n            node = node.left\n        else:\n            node = node.right\n    \n    if not node:\n        return None\n\n    if node.right:\n        return min_value_node(node.right)\n    \n    successor = None\n    ancestor = root\n    while ancestor != node:\n        if node.key < ancestor.key:\n            successor = ancestor\n            ancestor = ancestor.left\n        else:\n            ancestor = ancestor.right\n    \n    return successor\n\n# Helper function to build a tree from a list\ndef build_tree_from_list(values):\n    if not values:\n        return None\n    \n    nodes = [None if val is None else TreeNode(val) for val in values]\n    kids = nodes[::-1]\n    root = kids.pop()\n    \n    for node in nodes:\n        if node:\n            if kids:\n                node.left = kids.pop()\n            if kids:\n                node.right = kids.pop()\n    \n    return root\n\n# Test the function with the input BST\ninput_list = [20, 8, 22, 4, 12, None, None, None, None, 10, 14]\nroot = build_tree_from_list(input_list)\nnode_key = 8\nsuccessor = find_inorder_successor(root, node_key)\nprint(successor.key if successor else \"None\")  # Output: 10",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "05 Find All Paths in a Graph",
        "cpp_code": "#include <iostream>        // for input and output\n#include <vector>          // for std::vector\n#include <unordered_map>   // for std::unordered_map\n#include <unordered_set>   // for std::unordered_set\n\nvoid find_all_paths_dfs(const std::unordered_map<char, std::vector<char>>& graph, char current, char end, std::vector<char>& path, std::vector<std::vector<char>>& paths) {\n    path.push_back(current);\n    \n    if (current == end) {\n        paths.push_back(path);\n    } else {\n        for (char neighbor : graph.at(current)) {\n            if (std::find(path.begin(), path.end(), neighbor) == path.end()) {  // Avoid cycles\n                find_all_paths_dfs(graph, neighbor, end, path, paths);\n            }\n        }\n    }\n    \n    path.pop_back();  // Backtrack\n}\n\nstd::vector<std::vector<char>> find_all_paths(const std::unordered_map<char, std::vector<char>>& graph, char start, char end) {\n    std::vector<std::vector<char>> paths;\n    std::vector<char> path;\n    find_all_paths_dfs(graph, start, end, path, paths);\n    return paths;\n}\n\nint main() {\n    std::unordered_map<char, std::vector<char>> graph = {\n        {'A', {'B', 'C'}},\n        {'B', {'C', 'D'}},\n        {'C', {'D'}},\n        {'D', {}}\n    };\n    char start = 'A';\n    char end = 'D';\n    \n    std::vector<std::vector<char>> all_paths = find_all_paths(graph, start, end);\n    for (const auto& path : all_paths) {\n        for (char node : path) {\n            std::cout << node << \" \";\n        }\n        std::cout << std::endl;\n    }\n    \n    return 0;  // Return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "def find_all_paths_dfs(graph, current, end, path, paths):\n    path.append(current)\n\n    if current == end:\n        paths.append(path[:])   # Make a copy to avoid modifying the original list\n    else:\n        for neighbor in graph[current]:\n            if neighbor not in path:   # Avoid cycles\n                find_all_paths_dfs(graph, neighbor, end, path, paths)\n\n    path.pop()   # Backtrack\n\ndef find_all_paths(graph, start, end):\n    paths = []\n    path = []\n    find_all_paths_dfs(graph, start, end, path, paths)\n    return paths\n\nif __name__ == \"__main__\":\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': []\n    }\n    start = 'A'\n    end = 'D'\n\n    all_paths = find_all_paths(graph, start, end)\n    for path in all_paths:\n        print(' '.join(path))",
        "expected_python_code": "def find_all_paths(graph, start, end):\n    def dfs(current_node, path):\n        # Add the current node to the path\n        path.append(current_node)\n        \n        # If the current node is the end node, add the path to results\n        if current_node == end:\n            paths.append(path.copy())\n        else:\n            # Explore all neighbors\n            for neighbor in graph.get(current_node, []):\n                if neighbor not in path:  # Avoid cycles\n                    dfs(neighbor, path)\n        \n        # Backtrack: Remove the current node from path\n        path.pop()\n\n    paths = []\n    dfs(start, [])\n    return paths\n\n# Example usage\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['C', 'D'],\n    'C': ['D'],\n    'D': []\n}\nstart = 'A'\nend = 'D'\nall_paths = find_all_paths(graph, start, end)\nprint(all_paths)  # Output: [['A', 'B', 'D'], ['A', 'B', 'C', 'D'], ['A', 'C', 'D']]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "06 Word Search in Grid",
        "cpp_code": "#include <iostream>              // for input and output\n#include <vector>                // for std::vector\n\nbool dfs(const std::vector<std::vector<char>>& board, std::vector<std::vector<bool>>& visited, const std::string& word, int i, int j, int k) {\n    if (k == word.size()) return true;\n    if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[k] || visited[i][j]) return false;\n\n    visited[i][j] = true; // Mark the cell as visited\n\n    // Explore all 4 directions\n    bool found = dfs(board, visited, word, i + 1, j, k + 1) ||\n                 dfs(board, visited, word, i - 1, j, k + 1) ||\n                 dfs(board, visited, word, i, j + 1, k + 1) ||\n                 dfs(board, visited, word, i, j - 1, k + 1);\n\n    visited[i][j] = false; // Unmark the cell\n    return found;\n}\n\nbool exist(const std::vector<std::vector<char>>& board, const std::string& word) {\n    if (board.empty() || board[0].empty()) return false;\n\n    std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));\n\n    for (int i = 0; i < board.size(); ++i) {\n        for (int j = 0; j < board[0].size(); ++j) {\n            if (dfs(board, visited, word, i, j, 0)) return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    std::vector<std::vector<char>> board = {\n        {'A', 'B', 'C', 'E'},\n        {'S', 'F', 'C', 'S'},\n        {'A', 'D', 'E', 'E'}\n    };\n    std::string word = \"ABCCED\";\n    \n    std::cout << (exist(board, word) ? \"True\" : \"False\") << std::endl; // Output: True\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "def dfs(board, visited, word, i, j, k):\n    if k == len(word):\n        return True\n    if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k] or visited[i][j]:\n        return False\n\n    visited[i][j] = True\n    found = dfs(board, visited, word, i + 1, j, k + 1) or \\\n            dfs(board, visited, word, i - 1, j, k + 1) or \\\n            dfs(board, visited, word, i, j + 1, k + 1) or \\\n            dfs(board, visited, word, i, j - 1, k + 1)\n\n    visited[i][j] = False\n    return found\n\ndef exist(board, word):\n    if not board or not board[0]:\n        return False\n\n    visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if dfs(board, visited, word, i, j, 0):\n                return True\n\n    return False\n\ndef main():\n    board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]\n    word = \"ABCCED\"\n\n    print(\"True\" if exist(board, word) else \"False\")\n\nif __name__ == \"__main__\":\n    main()",
        "expected_python_code": "def exist(board, word):\n    def dfs(board, word, i, j, k):\n        if k == len(word):\n            return True\n        if (i < 0 or i >= len(board) or j < 0 or j >= len(board) or\n            board[i][j] != word[k]):\n            return False\n        \n        # Save the current cell's value and mark it as visited\n        temp = board[i][j]\n        board[i][j] = '#'\n        \n        # Explore all 4 directions: up, down, left, right\n        found = (dfs(board, word, i + 1, j, k + 1) or\n                 dfs(board, word, i - 1, j, k + 1) or\n                 dfs(board, word, i, j + 1, k + 1) or\n                 dfs(board, word, i, j - 1, k + 1))\n        \n        # Restore the current cell's value\n        board[i][j] = temp\n        \n        return found\n\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if dfs(board, word, i, j, 0):\n                return True\n    \n    return False\n\n# Example usage\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"]\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # Output: True",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "07 Implement Stack Using Queues by Make Push Operation Costly",
        "cpp_code": "#include <iostream>              // for input and output\n#include <queue>                 // for std::queue\n\nclass StackUsingQueues {\npublic:\n    void push(int x) {\n        queue2.push(x);\n        while (!queue1.empty()) {\n            queue2.push(queue1.front());\n            queue1.pop();\n        }\n        std::swap(queue1, queue2);\n    }\n\n    int pop() {\n        if (queue1.empty()) throw std::out_of_range(\"Pop from an empty stack\");\n        int value = queue1.front();\n        queue1.pop();\n        return value;\n    }\n\n    int top() {\n        if (queue1.empty()) throw std::out_of_range(\"Top from an empty stack\");\n        return queue1.front();\n    }\n\n    bool empty() {\n        return queue1.empty();\n    }\n\nprivate:\n    std::queue<int> queue1;\n    std::queue<int> queue2;\n};\n\n// Example usage\nint main() {\n    StackUsingQueues stack;\n    stack.push(1);\n    stack.push(2);\n    std::cout << stack.pop() << std::endl;  // Output: 2\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "import queue\n\nclass StackUsingQueues:\n    def __init__(self):\n        self.queue1 = queue.Queue()\n        self.queue2 = queue.Queue()\n\n    def push(self, x):\n        self.queue2.put(x)\n        while not self.queue1.empty():\n            self.queue2.put(self.queue1.get())\n            self.queue1.get()\n\n        # Swap names of queue1 and queue2\n        self.queue1, self.queue2 = self.queue2, self.queue1\n\n    def pop(self):\n        if self.queue1.empty():\n            raise IndexError(\"Pop from an empty stack\")\n\n        return self.queue1.get()\n\n    def top(self):\n        if self.queue1.empty():\n            raise IndexError(\"Top from an empty stack\")\n\n        return self.queue1.queue[0]\n\n    def empty(self):\n        return self.queue1.empty()\n\n# Example usage\nstack = StackUsingQueues()\nstack.push(1)\nstack.push(2)\nprint(stack.pop())  # Output: 2",
        "expected_python_code": "from collections import deque\n\nclass StackUsingQueues:\n    def __init__(self):\n        self.queue1 = deque()\n        self.queue2 = deque()\n\n    def push(self, x):\n        self.queue2.append(x)\n        while self.queue1:\n            self.queue2.append(self.queue1.popleft())\n        self.queue1, self.queue2 = self.queue2, self.queue1\n\n    def pop(self):\n        if not self.queue1:\n            raise IndexError(\"Pop from an empty stack\")\n        return self.queue1.popleft()\n\n    def top(self):\n        if not self.queue1:\n            raise IndexError(\"Top from an empty stack\")\n        return self.queue1[0]\n\n    def empty(self):\n        return not self.queue1\n\n# Example usage\nstack = StackUsingQueues()\nstack.push(1)\nstack.push(2)\nprint(stack.pop())  # Output: 2",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "08 Implement Stack Using Queues by Make Pop Operation Costly",
        "cpp_code": "#include <iostream>              // for input and output\n#include <queue>                 // for std::queue\n\nclass StackUsingQueues {\npublic:\n    void push(int x) {\n        queue1.push(x);\n    }\n\n    int pop() {\n        if (queue1.empty()) throw std::out_of_range(\"Pop from an empty stack\");\n        while (queue1.size() > 1) {\n            queue2.push(queue1.front());\n            queue1.pop();\n        }\n        int value = queue1.front();\n        queue1.pop();\n        std::swap(queue1, queue2);\n        return value;\n    }\n\n    int top() {\n        if (queue1.empty()) throw std::out_of_range(\"Top from an empty stack\");\n        while (queue1.size() > 1) {\n            queue2.push(queue1.front());\n            queue1.pop();\n        }\n        int value = queue1.front();\n        queue2.push(value);\n        queue1.pop();\n        std::swap(queue1, queue2);\n        return value;\n    }\n\n    bool empty() {\n        return queue1.empty();\n    }\n\nprivate:\n    std::queue<int> queue1;\n    std::queue<int> queue2;\n};\n\n// Example usage\nint main() {\n    StackUsingQueues stack;\n    stack.push(1);\n    stack.push(2);\n    std::cout << stack.pop() << std::endl;  // Output: 2\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "class StackUsingQueues:\n    def __init__(self):\n        self.queue1 = []\n        self.queue2 = []\n\n    def push(self, x):\n        self.queue1.append(x)\n\n    def pop(self):\n        if not self.queue1: raise IndexError(\"Pop from an empty stack\")\n        while len(self.queue1) > 1:\n            self.queue2.append(self.queue1[0])\n            self.queue1.pop(0)\n        value = self.queue1[0]\n        self.queue1.pop(0)\n        self.queue1, self.queue2 = self.queue2, self.queue1\n        return value\n\n    def top(self):\n        if not self.queue1: raise IndexError(\"Top from an empty stack\")\n        while len(self.queue1) > 1:\n            self.queue2.append(self.queue1[0])\n            self.queue1.pop(0)\n        value = self.queue1[0]\n        self.queue2.append(value)\n        self.queue1.pop(0)\n        self.queue1, self.queue2 = self.queue2, self.queue1\n        return value\n\n    def empty(self):\n        return not bool(self.queue1)\n\n# Example usage\nstack = StackUsingQueues()\nstack.push(1)\nstack.push(2)\nprint(stack.pop())  # Output: 2",
        "expected_python_code": "from collections import deque\n\nclass StackUsingQueues:\n    def __init__(self):\n        self.queue1 = deque()\n        self.queue2 = deque()\n\n    def push(self, x):\n        self.queue1.append(x)\n\n    def pop(self):\n        if not self.queue1:\n            raise IndexError(\"Pop from an empty stack\")\n        while len(self.queue1) > 1:\n            self.queue2.append(self.queue1.popleft())\n        value = self.queue1.popleft()\n        self.queue1, self.queue2 = self.queue2, self.queue1\n        return value\n\n    def top(self):\n        if not self.queue1:\n            raise IndexError(\"Top from an empty stack\")\n        while len(self.queue1) > 1:\n            self.queue2.append(self.queue1.popleft())\n        value = self.queue1[0]\n        self.queue2.append(self.queue1.popleft())\n        self.queue1, self.queue2 = self.queue2, self.queue1\n        return value\n\n    def empty(self):\n        return not self.queue1\n\n# Example usage\nstack = StackUsingQueues()\nstack.push(1)\nstack.push(2)\nprint(stack.pop())  # Output: 2",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "09 Sort a Stack",
        "cpp_code": "#include <iostream>              // for input and output\n#include <stack>                 // for std::stack\n\nvoid sortStack(std::stack<int>& stack) {\n    std::stack<int> auxStack;\n    \n    while (!stack.empty()) {\n        int temp = stack.top();\n        stack.pop();\n        \n        while (!auxStack.empty() && auxStack.top() > temp) {\n            stack.push(auxStack.top());\n            auxStack.pop();\n        }\n        \n        auxStack.push(temp);\n    }\n    \n    while (!auxStack.empty()) {\n        stack.push(auxStack.top());\n        auxStack.pop();\n    }\n}\n\n// Example usage\nint main() {\n    std::stack<int> stack;\n    stack.push(34);\n    stack.push(3);\n    stack.push(31);\n    stack.push(98);\n    stack.push(92);\n    stack.push(23);\n\n    sortStack(stack);\n\n    // Print sorted stack\n    while (!stack.empty()) {\n        std::cout << stack.top() << \" \";\n        stack.pop();\n    }\n    std::cout << std::endl;  // Output: 3 23 31 34 92 98\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "def sort_stack(stack):\n    auxStack = []\n\n    while stack:\n        temp = stack.pop()\n\n        while auxStack and auxStack[-1] > temp:\n            stack.append(auxStack.pop())\n\n        auxStack.append(temp)\n\n    return auxStack[::-1] # Reverse the list to get a sorted stack\n\n# Example usage\nif __name__ == \"__main__\":\n    stack = [34, 3, 31, 98, 92, 23]\n    sorted_stack = sort_stack(stack)\n\n    # Print sorted stack\n    while sorted_stack:\n        print(sorted_stack.pop(), end=\" \")\n\n    # Output: 3 23 31 34 92 98",
        "expected_python_code": "def sort_stack(stack):\n    # Create an auxiliary stack\n    aux_stack = []\n\n    while stack:\n        # Pop the top element from the main stack\n        temp = stack.pop()\n        \n        # While the auxiliary stack is not empty and the top of the auxiliary stack is greater than temp\n        while aux_stack and aux_stack[-1] > temp:\n            stack.append(aux_stack.pop())\n        \n        # Push the temp element onto the auxiliary stack\n        aux_stack.append(temp)\n    \n    # Transfer the sorted elements back to the main stack\n    while aux_stack:\n        stack.append(aux_stack.pop())\n\n# Example usage\nstack = [34, 3, 31, 98, 92, 23]\nsort_stack(stack)\nprint(stack)  # Output: [3, 23, 31, 34, 92, 98]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "10 Circular Queue Implementation",
        "cpp_code": "#include <iostream>              // for input and output\n#include <vector>                // for std::vector\n\nclass CircularQueue {\npublic:\n    CircularQueue(int size) : size(size), front(0), rear(-1), count(0) {\n        queue.resize(size);\n    }\n\n    void enqueue(int value) {\n        if (isFull()) throw std::out_of_range(\"Queue is full\");\n        rear = (rear + 1) % size;\n        queue[rear] = value;\n        ++count;\n    }\n\n    int dequeue() {\n        if (isEmpty()) throw std::out_of_range(\"Queue is empty\");\n        int value = queue[front];\n        front = (front + 1) % size;\n        --count;\n        return value;\n    }\n\n    int frontElement() {\n        if (isEmpty()) throw std::out_of_range(\"Queue is empty\");\n        return queue[front];\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    bool isFull() {\n        return count == size;\n    }\n\n    void printQueue() {\n        for (int i = 0; i < count; ++i) {\n            std::cout << queue[(front + i) % size] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\nprivate:\n    int size;\n    int front;\n    int rear;\n    int count;\n    std::vector<int> queue;\n};\n\n// Example usage\nint main() {\n    CircularQueue cq(5);\n    cq.enqueue(1);\n    cq.enqueue(2);\n    cq.dequeue();\n    cq.enqueue(3);\n    cq.printQueue();  // Output: 2 3\n    \n    return 0;  // Return 0 to indicate successful completion\n}",
        "translated_python_code": "class CircularQueue:\n    def __init__(self, size):\n        self.size = size\n        self.queue = [0]*size\n        self.head = 0\n        self.tail = -1\n        self.count = 0\n\n    def enqueue(self, value):\n        if self.isFull():\n            raise IndexError(\"Queue is full\")\n        self.tail = (self.tail + 1) % self.size\n        self.queue[self.tail] = value\n        self.count += 1\n\n    def dequeue(self):\n        if self.isEmpty():\n            raise IndexError(\"Queue is empty\")\n        data = self.queue[self.head]\n        self.head = (self.head + 1) % self.size\n        self.count -= 1\n        return data\n\n    def frontElement(self):\n        if self.isEmpty():\n            raise IndexError(\"Queue is empty\")\n        return self.queue[self.head]\n\n    def isEmpty(self):\n        return self.count == 0\n\n    def isFull(self):\n        return self.count == self.size\n\n    def printQueue(self):\n        for i in range(self.count):\n            print(self.queue[(self.head + i) % self.size], end=\" \")\n        print()\n\n# Example usage\nif __name__=='__main__':\n    cq = CircularQueue(5)\n    cq.enqueue(1)\n    cq.enqueue(2)\n    cq.dequeue()\n    cq.enqueue(3)\n    cq.printQueue()   # Output: 2 3",
        "expected_python_code": "class CircularQueue:\n    def __init__(self, size):\n        self.size = size\n        self.queue = [None] * size\n        self.front = 0\n        self.rear = -1\n        self.count = 0\n\n    def enqueue(self, value):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        self.rear = (self.rear + 1) % self.size\n        self.queue[self.rear] = value\n        self.count += 1\n\n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        value = self.queue[self.front]\n        self.queue[self.front] = None\n        self.front = (self.front + 1) % self.size\n        self.count -= 1\n        return value\n\n    def front_element(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n\n    def is_empty(self):\n        return self.count == 0\n\n    def is_full(self):\n        return self.count == self.size\n\n    def __str__(self):\n        return str([self.queue[(self.front + i) % self.size] for i in range(self.count)])\n\n# Example usage\ncq = CircularQueue(5)\ncq.enqueue(1)\ncq.enqueue(2)\ncq.dequeue()\ncq.enqueue(3)\nprint(cq)  # Output: [2, 3]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "11 String manipulation",
        "cpp_code": "string reverseString(string str) {\n    int n = str.length();\n    for(int i = 0; i < n/2; i++) {\n        swap(str[i], str[n-1-i]);\n    }\n    return str;\n}",
        "translated_python_code": "def reverse_string(str):\n    n = len(str)\n    str = list(str) # Convert string to list because strings are immutable in python\n    for i in range(n//2):\n        str[i], str[n-1-i] = str[n-1-i], str[i]\n    return \"\".join(str) # Join the characters back into a string",
        "expected_python_code": "def reverse_string(string):\n    return string[::-1]",
        "match_with_reference": false,
        "success": true,
        "error": null
    }
]