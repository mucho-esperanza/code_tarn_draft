[
    {
        "title": "01 Sudoku Solver",
        "cpp_code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool is_valid(vector<vector<int>>& board, int row, int col, int num) {\n    for (int i = 0; i < 9; ++i) {\n        if (board[row][i] == num || board[i][col] == num) {\n            return false;\n        }\n        if (board[row / 3 * 3 + i / 3][col / 3 * 3 + i % 3] == num) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool solve_sudoku(vector<vector<int>>& board) {\n    for (int i = 0; i < 9; ++i) {\n        for (int j = 0; j < 9; ++j) {\n            if (board[i][j] == 0) {\n                for (int num = 1; num <= 9; ++num) {\n                    if (is_valid(board, i, j, num)) {\n                        board[i][j] = num;\n                        if (solve_sudoku(board)) {\n                            return true;\n                        }\n                        board[i][j] = 0;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    vector<vector<int>> sudoku_board = {\n        {5, 3, 0, 0, 7, 0, 0, 0, 0},\n        {6, 0, 0, 1, 9, 5, 0, 0, 0},\n        {0, 9, 8, 0, 0, 0, 0, 6, 0},\n        {8, 0, 0, 0, 6, 0, 0, 0, 3},\n        {4, 0, 0, 8, 0, 3, 0, 0, 1},\n        {7, 0, 0, 0, 2, 0, 0, 0, 6},\n        {0, 6, 0, 0, 0, 0, 2, 8, 0},\n        {0, 0, 0, 4, 1, 9, 0, 0, 5},\n        {0, 0, 0, 0, 8, 0, 0, 7, 9}\n    };\n\n    if (solve_sudoku(sudoku_board)) {\n        for (const auto& row : sudoku_board) {\n            for (int num : row) {\n                cout << num << \" \";\n            }\n            cout << endl;\n        }\n    } else {\n        cout << \"No solution exists!\" << endl;\n    }\n\n    return 0;\n}",
        "translated_python_code": "def is_valid(board, row, col, num):\n    for i in range(9):\n        if board[row][i] == num or board[i][col] == num:\n            return False\n        if board[(row // 3) * 3 + i // 3][(col // 3) * 3 + i % 3] == num:\n            return False\n    return True\n\ndef solve_sudoku(board):\n    for row in range(9):\n        for col in range(9):\n            if board[row][col] == 0:\n                for num in range(1, 10):\n                    if is_valid(board, row, col, num):\n                        board[row][col] = num\n                        if solve_sudoku(board):\n                            return True\n                        board[row][col] = 0\n                return False\n    return True\n\ndef main():\n    sudoku_board = [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n\n    if solve_sudoku(sudoku_board):\n        for row in sudoku_board:\n            print(' '.join(map(str, row)))\n    else:\n        print(\"No solution exists!\")\n\nif __name__ == \"__main__\":\n    main()",
        "expected_python_code": "def is_valid(board, row, col, num):\n    # Check if 'num' is not in the current row, column, and 3x3 subgrid\n    for i in range(9):\n        if board[row][i] == num or board[i][col] == num:\n            return False\n        if board[row // 3 * 3 + i // 3][col // 3 * 3 + i % 3] == num:\n            return False\n    return True\n\ndef solve_sudoku(board):\n    def backtrack():\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if backtrack():\n                                return True\n                            board[i][j] = 0\n                    return False\n        return True\n\n    backtrack()\n    return board\n\n# Example usage\nsudoku_board = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9]\n]\n\nsolved_board = solve_sudoku(sudoku_board)\nfor row in solved_board:\n    print(row)",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "02 Knapsack Problem",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint knapsack(vector<int>& weights, vector<int>& values, int capacity) {\n    int n = weights.size();\n    vector<vector<int>> dp(n + 1, vector<int>(capacity + 1, 0));\n\n    for (int i = 1; i <= n; ++i) {\n        for (int w = 0; w <= capacity; ++w) {\n            if (weights[i - 1] <= w) {\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);\n            } else {\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n\n    return dp[n][capacity];\n}\n\nint main() {\n    int n, capacity;\n    n = 3;\n\n    vector<int> weights(n);\n    vector<int> values(n);\n\n    cout << \"Enter the weights of the items:\n\";\n    for (int i = 0; i < n; ++i) {\n        cin >> weights[i];\n    }\n\n    cout << \"Enter the values of the items:\n\";\n    for (int i = 0; i < n; ++i) {\n        cin >> values[i];\n    }\n\n    cout << \"Enter the capacity of the knapsack: \";\n    cin >> capacity;\n\n    int max_value = knapsack(weights, values, capacity);\n    cout << \"Maximum Value: \" << max_value << endl;\n\n    return 0;\n}",
        "translated_python_code": "def knapsack(weights, values, capacity):\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if weights[i - 1] <= w:\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w])\n            else:\n                dp[i][w] = dp[i - 1][w]\n\n    return dp[n][capacity]\n\ndef main():\n    n = int(input(\"Enter the number of items: \"))\n\n    weights = [int(input(f\"Enter weight for item {i+1}: \")) for i in range(n)]\n    values = [int(input(f\"Enter value for item {i+1}: \")) for i in range(n)]\n\n    capacity = int(input(\"Enter the capacity of the knapsack: \"))\n\n    max_value = knapsack(weights, values, capacity)\n    print(f\"Maximum Value: {max_value}\")\n\nif __name__ == \"__main__\":\n    main()",
        "expected_python_code": "def knapsack(weights, values, capacity):\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if weights[i - 1] <= w:\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w])\n            else:\n                dp[i][w] = dp[i - 1][w]\n\n    return dp[n][capacity]\n\n# Example usage\nweights = [1, 3, 4]\nvalues = [15, 20, 30]\ncapacity = 4\n\nmax_value = knapsack(weights, values, capacity)\nprint(\"Maximum Value:\", max_value)",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "03 LRU Cache Implementation",
        "cpp_code": "#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Node {\npublic:\n    int key;\n    int value;\n    Node* prev;\n    Node* next;\n    Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    int capacity;\n    unordered_map<int, Node*> cache;\n    Node* head;\n    Node* tail;\n\n    void remove(Node* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void add(Node* node) {\n        node->prev = tail->prev;\n        node->next = tail;\n        tail->prev->next = node;\n        tail->prev = node;\n    }\n\npublic:\n    LRUCache(int cap) : capacity(cap) {\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head->next = tail;\n        tail->prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node* node = cache[key];\n            remove(node);\n            add(node);\n            return node->value;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            remove(cache[key]);\n            delete cache[key];\n        }\n        Node* node = new Node(key, value);\n        add(node);\n        cache[key] = node;\n        if (cache.size() > capacity) {\n            Node* lru = head->next;\n            remove(lru);\n            cache.erase(lru->key);\n            delete lru;\n        }\n    }\n};\n\n// Example usage\nint main() {\n    LRUCache cache(2);\n    cache.put(1, 1);\n    cache.put(2, 2);\n    cout << cache.get(1) << endl;  // Output: 1\n    cache.put(3, 3);\n    cout << cache.get(2) << endl;  // Output: -1\n    return 0;\n}",
        "translated_python_code": "class Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self.remove(node)\n            self.add(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            del self.cache[key]\n        node = Node(key, value)\n        self.add(node)\n        self.cache[key] = node\n        if len(self.cache) > self.capacity:\n            lru = self.head.next\n            self.remove(lru)\n            del self.cache[lru.key]\n\n    def remove(self, node: Node) -> None:\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add(self, node: Node) -> None:\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev.next = node\n        self.tail.prev = node\n\n# Example usage\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nprint(cache.get(1))  # Output: 1\ncache.put(3, 3)\nprint(cache.get(2))  # Output: -1",
        "expected_python_code": "class Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove(self, node):\n        prev = node.prev\n        next = node.next\n        prev.next = next\n        next.prev = prev\n\n    def _add(self, node):\n        prev = self.tail.prev\n        prev.next = node\n        node.prev = prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            self._add(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self._remove(self.cache[key])\n        node = Node(key, value)\n        self._add(node)\n        self.cache[key] = node\n        if len(self.cache) > self.capacity:\n            lru = self.head.next\n            self._remove(lru)\n            del self.cache[lru.key]\n\n# Example usage\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nprint(cache.get(1))  # Output: 1\ncache.put(3, 3)\nprint(cache.get(2))  # Output: -1",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "04 Word Ladder",
        "cpp_code": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<string> wordLadder(string beginWord, string endWord, vector<string>& wordList) {\n    unordered_set<string> wordSet(wordList.begin(), wordList.end());\n    if (wordSet.find(endWord) == wordSet.end()) {\n        return {};\n    }\n    \n    unordered_map<string, vector<string>> allComboDict;\n    int L = beginWord.length();\n    \n    for (const string& word : wordList) {\n        for (int i = 0; i < L; ++i) {\n            string newWord = word.substr(0, i) + '*' + word.substr(i + 1, L - i - 1);\n            allComboDict[newWord].push_back(word);\n        }\n    }\n    \n    queue<pair<string, vector<string>>> q;\n    q.push({beginWord, {beginWord}});\n    unordered_set<string> visited = {beginWord};\n    \n    while (!q.empty()) {\n        auto [currentWord, path] = q.front();\n        q.pop();\n        \n        for (int i = 0; i < L; ++i) {\n            string intermediateWord = currentWord.substr(0, i) + '*' + currentWord.substr(i + 1, L - i - 1);\n            \n            for (const string& word : allComboDict[intermediateWord]) {\n                if (word == endWord) {\n                    path.push_back(endWord);\n                    return path;\n                }\n                \n                if (visited.find(word) == visited.end()) {\n                    visited.insert(word);\n                    vector<string> newPath = path;\n                    newPath.push_back(word);\n                    q.push({word, newPath});\n                }\n            }\n        }\n    }\n    \n    return {};\n}\n\nint main() {\n    string beginWord = \"hit\";\n    string endWord = \"cog\";\n    vector<string> wordList = {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"};\n    vector<string> result = wordLadder(beginWord, endWord, wordList);\n    \n    for (const string& word : result) {\n        cout << word << \" \";\n    }\n    // Output: hit hot dot dog cog\n    return 0;\n}",
        "translated_python_code": "from collections import deque, defaultdict\n\ndef word_ladder(begin_word, end_word, word_list):\n    word_set = set(word_list)\n    if end_word not in word_set:\n        return []\n\n    all_combo_dict = defaultdict(list)\n    L = len(begin_word)\n\n    for word in word_list:\n        for i in range(L):\n            intermediate_word = word[:i] + '*' + word[i+1:]\n            all_combo_dict[intermediate_word].append(word)\n\n    q = deque([(begin_word, [begin_word])])\n    visited = {begin_word}\n\n    while q:\n        current_word, path = q.popleft()\n\n        for i in range(L):\n            intermediate_word = current_word[:i] + '*' + current_word[i+1:]\n\n            for word in all_combo_dict[intermediate_word]:\n                if word == end_word:\n                    return path + [end_word]\n\n                if word not in visited:\n                    visited.add(word)\n                    q.append((word, path + [word]))\n\n    return []\n\nif __name__ == \"__main__\":\n    begin_word = \"hit\"\n    end_word = \"cog\"\n    word_list = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\n    result = word_ladder(begin_word, end_word, word_list)\n\n    for word in result:\n        print(word, end=\" \")",
        "expected_python_code": "from collections import deque, defaultdict\n\ndef word_ladder(begin_word, end_word, word_list):\n    if end_word not in word_list:\n        return []\n\n    # Preprocess word list to create a dictionary of possible transformations\n    word_list.append(begin_word)\n    all_combo_dict = defaultdict(list)\n    L = len(begin_word)\n    \n    for word in word_list:\n        for i in range(L):\n            all_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\n\n    # BFS initialization\n    queue = deque([(begin_word, [begin_word])])\n    visited = set([begin_word])\n\n    while queue:\n        current_word, path = queue.popleft()\n        for i in range(L):\n            intermediate_word = current_word[:i] + \"*\" + current_word[i+1:]\n\n            for word in all_combo_dict[intermediate_word]:\n                if word == end_word:\n                    return path + [end_word]\n                \n                if word not in visited:\n                    visited.add(word)\n                    queue.append((word, path + [word]))\n    return []\n\n# Example usage\nbegin_word = \"hit\"\nend_word = \"cog\"\nword_list = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(word_ladder(begin_word, end_word, word_list))  # Output: ['hit', 'hot', 'dot', 'dog', 'cog']",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "05 K-th Largest Element",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nint partition(vector<int>& nums, int left, int right) {\n    int pivot_index = left + rand() % (right - left + 1);\n    swap(nums[pivot_index], nums[right]);\n    int pivot = nums[right];\n    int i = left;\n    for (int j = left; j < right; ++j) {\n        if (nums[j] <= pivot) {\n            swap(nums[i], nums[j]);\n            ++i;\n        }\n    }\n    swap(nums[i], nums[right]);\n    return i;\n}\n\nint quickselect(vector<int>& nums, int left, int right, int k) {\n    if (left == right) {\n        return nums[left];\n    }\n    \n    int pivot_index = partition(nums, left, right);\n    \n    if (k == pivot_index) {\n        return nums[k];\n    } else if (k < pivot_index) {\n        return quickselect(nums, left, pivot_index - 1, k);\n    } else {\n        return quickselect(nums, pivot_index + 1, right, k);\n    }\n}\n\nint findKthLargest(vector<int>& nums, int k) {\n    int size = nums.size();\n    srand(time(0));\n    return quickselect(nums, 0, size - 1, size - k);\n}\n\nint main() {\n    int n, k;\n\n    cout << \"Enter the number of elements: \";\n    cin >> n;\n\n    vector<int> nums(n);\n\n    cout << \"Enter the elements:\n\";\n    for (int i = 0; i < n; ++i) {\n        cin >> nums[i];\n    }\n\n    cout << \"Enter the value of k: \";\n    cin >> k;\n\n    cout << findKthLargest(nums, k) << endl;  // Output the k-th largest element\n    return 0;\n}",
        "translated_python_code": "import random\n\ndef partition(nums, left, right):\n    pivot_index = left + random.randint(0, right - left)\n    nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n    pivot = nums[right]\n    i = left\n    for j in range(left, right):\n        if nums[j] <= pivot:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n    nums[i], nums[right] = nums[right], nums[i]\n    return i\n\ndef quickselect(nums, left, right, k):\n    if left == right:\n        return nums[left]\n\n    pivot_index = partition(nums, left, right)\n\n    if k == pivot_index:\n        return nums[k]\n    elif k < pivot_index:\n        return quickselect(nums, left, pivot_index - 1, k)\n    else:\n        return quickselect(nums, pivot_index + 1, right, k)\n\ndef find_kth_largest(nums, k):\n    size = len(nums)\n    random.seed(time.time())\n    return quickselect(nums, 0, size - 1, size - k)\n\nif __name__ == \"__main__\":\n    n, k = map(int, input(\"Enter the number of elements and the value of k: \").split())\n\n    nums = list(map(int, input(\"Enter the elements separated by spaces: \").split()))\n\n    print(find_kth_largest(nums, k))  # Output the k-th largest element",
        "expected_python_code": "import random\n\ndef partition(nums, left, right):\n    pivot_index = random.randint(left, right)\n    nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n    pivot = nums[right]\n    i = left\n    for j in range(left, right):\n        if nums[j] <= pivot:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n    nums[i], nums[right] = nums[right], nums[i]\n    return i\n\ndef quickselect(nums, left, right, k):\n    if left == right:\n        return nums[left]\n    \n    pivot_index = partition(nums, left, right)\n    \n    if k == pivot_index:\n        return nums[k]\n    elif k < pivot_index:\n        return quickselect(nums, left, pivot_index - 1, k)\n    else:\n        return quickselect(nums, pivot_index + 1, right, k)\n\ndef findKthLargest(nums, k):\n    size = len(nums)\n    return quickselect(nums, 0, size - 1, size - k)\n\n# Example usage\nnums = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(findKthLargest(nums, k))  # Output: 5",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "06 Graph Traversal Depth-First Search",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(unordered_map<char, vector<char>>& graph, char start) {\n    vector<char> visited;\n    stack<char> stack;\n    stack.push(start);\n\n    while (!stack.empty()) {\n        char node = stack.top();\n        stack.pop();\n        \n        if (find(visited.begin(), visited.end(), node) == visited.end()) {\n            visited.push_back(node);\n            for (auto it = graph[node].rbegin(); it != graph[node].rend(); ++it) {\n                stack.push(*it);\n            }\n        }\n    }\n\n    for (char node : visited) {\n        cout << node << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    unordered_map<char, vector<char>> graph;\n    graph['A'] = {'B', 'C'};\n    graph['B'] = {'D', 'E'};\n    graph['C'] = {'F', 'G'};\n    graph['D'] = {};\n    graph['E'] = {};\n    graph['F'] = {};\n    graph['G'] = {};\n\n    char start = 'A';\n    dfs(graph, start);  // Output: A B D E C F G\n    return 0;\n}",
        "translated_python_code": "from collections import defaultdict\n\ndef dfs(graph, start):\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if node not in visited:\n            visited.add(node)\n            stack.extend(reversed(graph[node]))\n\n    for node in sorted(visited):\n        print(node, end=' ')\n    print()\n\ndef main():\n    graph = defaultdict(list)\n    graph['A'] = ['B', 'C']\n    graph['B'] = ['D', 'E']\n    graph['C'] = ['F', 'G']\n    graph['D'] = []\n    graph['E'] = []\n    graph['F'] = []\n    graph['G'] = []\n\n    start = 'A'\n    dfs(graph, start)  # Output: A B D E C F G\n\nif __name__ == \"__main__\":\n    main()",
        "expected_python_code": "def dfs(graph, start):\n    visited = []\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.append(node)\n            stack.extend(reversed(graph.get(node, [])))\n    \n    return visited\n\n# Example usage\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F', 'G'],\n    'D': [],\n    'E': [],\n    'F': [],\n    'G': []\n}\nstart = 'A'\nprint(dfs(graph, start))  # Output: ['A', 'B', 'D', 'E', 'C', 'F', 'G']",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "07 Graph Traversal Breadth-First Search",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nvoid bfs(unordered_map<char, vector<char>>& graph, char start) {\n    vector<char> visited;\n    queue<char> queue;\n    queue.push(start);\n\n    while (!queue.empty()) {\n        char node = queue.front();\n        queue.pop();\n\n        if (find(visited.begin(), visited.end(), node) == visited.end()) {\n            visited.push_back(node);\n            for (char neighbor : graph[node]) {\n                queue.push(neighbor);\n            }\n        }\n    }\n\n    for (char node : visited) {\n        cout << node << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    unordered_map<char, vector<char>> graph;\n    graph['A'] = {'B', 'C'};\n    graph['B'] = {'D', 'E'};\n    graph['C'] = {'F', 'G'};\n    graph['D'] = {};\n    graph['E'] = {};\n    graph['F'] = {};\n    graph['G'] = {};\n\n    char start = 'A';\n    bfs(graph, start);  // Output: A B C D E F G\n    return 0;\n}",
        "translated_python_code": "from collections import defaultdict\n\ndef bfs(graph, start):\n    visited = set()\n    queue = [start]\n\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                queue.append(neighbor)\n\n    print(' '.join(visited))\n\nif __name__ == \"__main__\":\n    graph = defaultdict(list)\n    graph['A'].append('B')\n    graph['A'].append('C')\n    graph['B'].append('D')\n    graph['B'].append('E')\n    graph['C'].append('F')\n    graph['C'].append('G')\n    graph['D'] = []\n    graph['E'] = []\n    graph['F'] = []\n    graph['G'] = []\n\n    start = 'A'\n    bfs(graph, start)  # Output: A B C D E F G",
        "expected_python_code": "def bfs(graph, start):\n    visited = []\n    queue = [start]\n    \n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.append(node)\n            queue.extend(graph.get(node, []))\n    \n    return visited\n\n# Example usage\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F', 'G'],\n    'D': [],\n    'E': [],\n    'F': [],\n    'G': []\n}\nstart = 'A'\nprint(bfs(graph, start))  # Output: ['A', 'B', 'C', 'D', 'E', 'F', 'G']",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "08 Dijkstra Algorithm",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <limits>\n#include <utility>\n\nusing namespace std;\n\nunordered_map<char, int> dijkstra(unordered_map<char, unordered_map<char, int>>& graph, char start) {\n    // Initialize distances with infinity\n    unordered_map<char, int> distances;\n    for (auto& node : graph) {\n        distances[node.first] = numeric_limits<int>::max();\n    }\n    distances[start] = 0;\n    \n    // Priority queue to store the (distance, node)\n    priority_queue<pair<int, char>, vector<pair<int, char>>, greater<pair<int, char>>> pq;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int current_distance = pq.top().first;\n        char current_node = pq.top().second;\n        pq.pop();\n        \n        // If the popped node has a greater distance than the recorded one, continue\n        if (current_distance > distances[current_node]) {\n            continue;\n        }\n        \n        // Update distances of neighbors\n        for (auto& neighbor : graph[current_node]) {\n            char neighbor_node = neighbor.first;\n            int weight = neighbor.second;\n            int distance = current_distance + weight;\n            \n            // If a shorter path is found\n            if (distance < distances[neighbor_node]) {\n                distances[neighbor_node] = distance;\n                pq.push({distance, neighbor_node});\n            }\n        }\n    }\n    \n    return distances;\n}\n\nint main() {\n    unordered_map<char, unordered_map<char, int>> graph;\n    graph['A'] = {{'B', 1}, {'C', 4}};\n    graph['B'] = {{'C', 2}, {'D', 5}};\n    graph['C'] = {{'D', 1}};\n    graph['D'] = {};\n\n    char start = 'A';\n    unordered_map<char, int> result = dijkstra(graph, start);\n\n    for (auto& pair : result) {\n        cout << pair.first << \": \" << pair.second << endl;\n    }\n    // Output: \n    // A: 0\n    // B: 1\n    // C: 3\n    // D: 4\n\n    return 0;\n}",
        "translated_python_code": "from collections import defaultdict, PriorityQueue\n\ndef dijkstra(graph, start):\n    # Initialize distances with infinity\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    # Priority queue to store the (distance, node)\n    pq = PriorityQueue()\n    pq.put((0, start))\n\n    while not pq.empty():\n        current_distance, current_node = pq.get()\n\n        # If the popped node has a greater distance than the recorded one, continue\n        if current_distance > distances[current_node]:\n            continue\n\n        # Update distances of neighbors\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            # If a shorter path is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                pq.put((distance, neighbor))\n\n    return distances\n\nif __name__ == \"__main__\":\n    graph = defaultdict(dict)\n    graph['A']['B'] = 1\n    graph['A']['C'] = 4\n    graph['B']['C'] = 2\n    graph['B']['D'] = 5\n    graph['C']['D'] = 1\n\n    start = 'A'\n    result = dijkstra(graph, start)\n\n    for node, distance in result.items():\n        print(f\"{node}: {distance}\")\n    # Output:\n    # A: 0\n    # B: 1\n    # C: 3\n    # D: 4",
        "expected_python_code": "import heapq\n\ndef dijkstra(graph, start):\n    # Initialize distances with infinity\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store the (distance, node)\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If the popped node has a greater distance than the recorded one, continue\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Update distances of neighbors\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            \n            # If a shorter path is found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\n# Example usage\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'C': 2, 'D': 5},\n    'C': {'D': 1},\n    'D': {}\n}\nstart = 'A'\nprint(dijkstra(graph, start))  # Output: {'A': 0, 'B': 1, 'C': 3, 'D': 4}",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "09 Median of Two Sorted Arrays",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n\n    int x = nums1.size();\n    int y = nums2.size();\n    int low = 0, high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n        int minX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n        \n        int maxY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n        int minY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n        \n        if (maxX <= minY && maxY <= minX) {\n            if ((x + y) % 2 == 0) {\n                return ((double)max(maxX, maxY) + min(minX, minY)) / 2;\n            } else {\n                return (double)max(maxX, maxY);\n            }\n        } else if (maxX > minY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }\n    \n    throw invalid_argument(\"Input arrays are not sorted\");\n}\n\nint main() {\n    int n1, n2;\n\n    cout << \"Enter the number of elements in the first array: \";\n    cin >> n1;\n\n    vector<int> nums1(n1);\n    cout << \"Enter the elements of the first array:\n\";\n    for (int i = 0; i < n1; ++i) {\n        cin >> nums1[i];\n    }\n\n    cout << \"Enter the number of elements in the second array: \";\n    cin >> n2;\n\n    vector<int> nums2(n2);\n    cout << \"Enter the elements of the second array:\n\";\n    for (int i = 0; i < n2; ++i) {\n        cin >> nums2[i];\n    }\n\n    try {\n        double median = findMedianSortedArrays(nums1, nums2);\n        cout << \"Median: \" << median << endl;\n    } catch (const invalid_argument& e) {\n        cout << e.what() << endl;\n    }\n\n    return 0;\n}",
        "translated_python_code": "def find_median_sorted_arrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return find_median_sorted_arrays(nums2, nums1)\n\n    x = len(nums1)\n    y = len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        max_x = nums1[partition_x - 1] if partition_x > 0 else float('-inf')\n        min_x = nums1[partition_x] if partition_x < x else float('inf')\n\n        max_y = nums2[partition_y - 1] if partition_y > 0 else float('-inf')\n        min_y = nums2[partition_y] if partition_y < y else float('inf')\n\n        if max_x <= min_y and max_y <= min_x:\n            if (x + y) % 2 == 0:\n                return (max(max_x, max_y) + min(min_x, min_y)) / 2\n            else:\n                return max(max_x, max_y)\n        elif max_x > min_y:\n            high = partition_x - 1\n        else:\n            low = partition_x + 1\n\n    raise ValueError(\"Input arrays are not sorted\")\n\ndef main():\n    n1 = int(input(\"Enter the number of elements in the first array: \"))\n    nums1 = list(map(int, input(f\"Enter the elements of the first array:\\n\").split()))\n\n    n2 = int(input(\"Enter the number of elements in the second array: \"))\n    nums2 = list(map(int, input(f\"Enter the elements of the second array:\\n\").split()))\n\n    try:\n        median = find_median_sorted_arrays(nums1, nums2)\n        print(f\"Median: {median}\")\n    except ValueError as e:\n        print(e)\n\nif __name__ == \"__main__\":\n    main()",
        "expected_python_code": "def findMedianSortedArrays(nums1, nums2):\n    # Ensure nums1 is the smaller array\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n    \n    while low <= high:\n        partitionX = (low + high) // 2\n        partitionY = (x + y + 1) // 2 - partitionX\n        \n        maxX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n        minX = float('inf') if partitionX == x else nums1[partitionX]\n        \n        maxY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n        minY = float('inf') if partitionY == y else nums2[partitionY]\n        \n        if maxX <= minY and maxY <= minX:\n            if (x + y) % 2 == 0:\n                return (max(maxX, maxY) + min(minX, minY)) / 2\n            else:\n                return max(maxX, maxY)\n        elif maxX > minY:\n            high = partitionX - 1\n        else:\n            low = partitionX + 1\n    \n    raise ValueError(\"Input arrays are not sorted\")\n\n# Example usage\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArrays(nums1, nums2))  # Output: 2.0",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "10 N-Queens Problem",
        "cpp_code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool isSafe(vector<string> &board, int row, int col, int N) {\n    for (int i = 0; i < row; i++) {\n        if (board[i][col] == 'Q') return false;\n        if (col - (row - i) >= 0 && board[i][col - (row - i)] == 'Q') return false;\n        if (col + (row - i) < N && board[i][col + (row - i)] == 'Q') return false;\n    }\n    return true;\n}\n\nvoid solve(vector<vector<string>> &result, vector<string> &board, int row, int N) {\n    if (row == N) {\n        result.push_back(board);\n        return;\n    }\n    for (int col = 0; col < N; col++) {\n        if (isSafe(board, row, col, N)) {\n            board[row][col] = 'Q';\n            solve(result, board, row + 1, N);\n            board[row][col] = '.';\n        }\n    }\n}\n\nvector<vector<string>> solveNQueens(int N) {\n    vector<vector<string>> result;\n    vector<string> board(N, string(N, '.'));\n    solve(result, board, 0, N);\n    return result;\n}\n\nint main() {\n    int N = 4;\n    vector<vector<string>> solutions = solveNQueens(N);\n    for (const auto &solution : solutions) {\n        for (const auto &row : solution) {\n            cout << row << endl;\n        }\n        cout << endl;\n    }\n    // Output: [[\".Q..\", \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", \"Q...\", \"...Q\", \".Q..\"]]\n    return 0;\n}",
        "translated_python_code": "def is_safe(board, row, col, N):\n    for i in range(row):\n        if board[i][col] == 'Q':\n            return False\n        if col - (row - i) >= 0 and board[i][col - (row - i)] == 'Q':\n            return False\n        if col + (row - i) < N and board[i][col + (row - i)] == 'Q':\n            return False\n    return True\n\ndef solve(board, row, N):\n    if row == N:\n        result.append(board[:])\n        return\n    for col in range(N):\n        if is_safe(board, row, col, N):\n            board[row][col] = 'Q'\n            solve(board, row + 1, N)\n            board[row][col] = '.'\n\ndef solve_n_queens(N):\n    result = []\n    board = [['.' for _ in range(N)] for _ in range(N)]\n    solve(board, 0, N)\n    return result\n\nif __name__ == \"__main__\":\n    N = 4\n    solutions = solve_n_queens(N)\n    for solution in solutions:\n        print(solution)\n    # Output: [[\".Q..\", \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", \"Q...\", \"...Q\", \".Q..\"]]",
        "expected_python_code": "def solveNQueens(N):\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 'Q':\n                return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 'Q':\n                return False\n            if col + (row - i) < N and board[i][col + (row - i)] == 'Q':\n                return False\n        return True\n    \n    def solve(board, row):\n        if row == N:\n            result.append([''.join(row) for row in board])\n            return\n        for col in range(N):\n            if is_safe(board, row, col):\n                board[row][col] = 'Q'\n                solve(board, row + 1)\n                board[row][col] = '.'\n    \n    result = []\n    board = [['.' for _ in range(N)] for _ in range(N)]\n    solve(board, 0)\n    return result\n\n# Example usage\nN = 4\nprint(solveNQueens(N))\n# Output: [['.Q..', '...Q', 'Q...', '..Q.'], ['..Q.', 'Q...', '...Q', '.Q..']]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "11 Trie Implementation",
        "cpp_code": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nclass TrieNode {\npublic:\n    unordered_map<char, TrieNode*> children;\n    bool is_end_of_word;\n\n    TrieNode() : is_end_of_word(false) {}\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n    \n    void insert(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->children.find(c) == node->children.end()) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        node->is_end_of_word = true;\n    }\n    \n    bool search(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->children.find(c) == node->children.end()) {\n                return false;\n            }\n            node = node->children[c];\n        }\n        return node->is_end_of_word;\n    }\n    \n    bool startsWith(string prefix) {\n        TrieNode* node = root;\n        for (char c : prefix) {\n            if (node->children.find(c) == node->children.end()) {\n                return false;\n            }\n            node = node->children[c];\n        }\n        return true;\n    }\n};\n\nint main() {\n    Trie trie;\n    trie.insert(\"hello\");\n    trie.insert(\"world\");\n    cout << trie.search(\"hello\") << endl;  // Output: 1 (true)\n    cout << trie.search(\"world\") << endl;  // Output: 1 (true)\n    cout << trie.search(\"hell\") << endl;   // Output: 0 (false)\n    cout << trie.startsWith(\"wor\") << endl;  // Output: 1 (true)\n    cout << trie.startsWith(\"worl\") << endl; // Output: 1 (true)\n    cout << trie.startsWith(\"worr\") << endl; // Output: 0 (false)\n    return 0;\n}",
        "translated_python_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\nif __name__ == \"__main__\":\n    trie = Trie()\n    trie.insert(\"hello\")\n    trie.insert(\"world\")\n    print(trie.search(\"hello\"))  # Output: True\n    print(trie.search(\"world\"))  # Output: True\n    print(trie.search(\"hell\"))   # Output: False\n    print(trie.startsWith(\"wor\"))  # Output: True\n    print(trie.startsWith(\"worl\")) # Output: True\n    print(trie.startsWith(\"worr\")) # Output: False",
        "expected_python_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n    \n    def starts_with(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\n# Example usage\ntrie = Trie()\ntrie.insert(\"hello\")\ntrie.insert(\"world\")\nprint(trie.search(\"hello\"))  # Output: True\nprint(trie.search(\"world\"))  # Output: True\nprint(trie.search(\"hell\"))   # Output: False\nprint(trie.starts_with(\"wor\"))  # Output: True\nprint(trie.starts_with(\"worl\")) # Output: True\nprint(trie.starts_with(\"worr\")) # Output: False",
        "match_with_reference": false,
        "success": true,
        "error": null
    }
]