[
    {
        "title": "01 Binary Search",
        "cpp_code": "#include <iostream> // include the iostream library for input and output\n#include <vector>   // include the vector library for std::vector\n\nint binary_search(const std::vector<int>& arr, int target) {\n    int left = 0, right = arr.size() - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2; // Avoid overflow\n        if (arr[mid] == target) {\n            return mid; // Return the index if the target is found\n        } else if (arr[mid] < target) {\n            left = mid + 1; // Search in the right half\n        } else {\n            right = mid - 1; // Search in the left half\n        }\n    }\n    \n    return -1; // Return -1 if the target is not found\n}\n\nint main() {\n    std::vector<int> input_array = {1, 2, 3, 4, 5, 6};\n    int target_value = 4;\n    int index = binary_search(input_array, target_value);\n    std::cout << \"Index: \" << index << std::endl; // Output: Index: 3\n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "# include <iostream> # include the iostream library for input and output\n# include <vector>   # include the vector library for std::vector\n\ndef binary_search(arr, target):\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef main():\n    input_array = [1, 2, 3, 4, 5, 6]\n    target_value = 4\n    index = binary_search(input_array, target_value)\n    print(\"Index:\", index) # Output: Index: 3\n    return 0 # return 0 to indicate the program ended successfully",
        "expected_python_code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid  # Return the index if the target is found\n        elif arr[mid] < target:\n            left = mid + 1  # Search in the right half\n        else:\n            right = mid - 1  # Search in the left half\n            \n    return -1  # Return -1 if the target is not found\n\n# Test the function with the input [1, 2, 3, 4, 5, 6] and target 4\ninput_array = [1, 2, 3, 4, 5, 6]\ntarget_value = 4\nindex = binary_search(input_array, target_value)\nprint(f\"Index: {index}\") # Output: Index: 3",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "02 Anagram Check",
        "cpp_code": "#include <iostream> // include the iostream library for input and output\n#include <algorithm> // include the algorithm library for std::sort\n#include <cctype> // include the cctype library for std::tolower\n#include <string> // include the string library for std::string\n\nbool are_anagrams(const std::string& str1, const std::string& str2) {\n    // Convert both strings to lowercase\n    std::string s1 = str1;\n    std::string s2 = str2;\n    for (char& c : s1) {\n        c = std::tolower(c);\n    }\n    for (char& c : s2) {\n        c = std::tolower(c);\n    }\n    \n    // Remove spaces from both strings\n    s1.erase(std::remove(s1.begin(), s1.end(), ' '), s1.end());\n    s2.erase(std::remove(s2.begin(), s2.end(), ' '), s2.end());\n    \n    // Check if lengths are the same\n    if (s1.length() != s2.length()) {\n        return false;\n    }\n    \n    // Sort both strings and compare\n    std::sort(s1.begin(), s1.end());\n    std::sort(s2.begin(), s2.end());\n    return s1 == s2;\n}\n\nint main() {\n    std::string input_str1 = \"listen\";\n    std::string input_str2 = \"silent\";\n    std::cout << std::boolalpha << are_anagrams(input_str1, input_str2) << std::endl; // Output: true\n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "#include <iostream> # include the iostream library for input and output\n#include <algorithm> # include the algorithm library for std::sort\n#include <cctype> # include the cctype library for std::tolower\n#include <string> # include the string library for std::string\n\ndef are_anagrams(str1, str2):\n    # Convert both strings to lowercase\n    s1 = str1.lower()\n    s2 = str2.lower()\n\n    # Remove spaces from both strings\n    s1 = s1.replace(\" \", \"\")\n    s2 = s2.replace(\" \", \"\")\n\n    # Check if lengths are the same\n    if len(s1) != len(s2):\n        return False\n\n    # Sort both strings and compare\n    s1_sorted = sorted(s1)\n    s2_sorted = sorted(s2)\n    return s1_sorted == s2_sorted\n\ndef main():\n    input_str1 = \"listen\"\n    input_str2 = \"silent\"\n    print(are_anagrams(input_str1, input_str2)) # Output: true\n    return 0 # return 0 to indicate the program ended successfully",
        "expected_python_code": "def are_anagrams(str1, str2):\n    # Remove spaces and convert to lowercase\n    str1 = str1.replace(\" \", \"\").lower()\n    str2 = str2.replace(\" \", \"\").lower()\n    \n    # Check if lengths are the same\n    if len(str1) != len(str2):\n        return False\n    \n    # Sort both strings and compare\n    return sorted(str1) == sorted(str2)\n\n# Test the function with the input \"listen\" and \"silent\"\ninput_str1 = \"listen\"\ninput_str2 = \"silent\"\nprint(are_anagrams(input_str1, input_str2)) # Output: True",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "03 Merge Sort",
        "cpp_code": "#include <iostream> // include the iostream library for input and output\n#include <vector>   // include the vector library for std::vector\n\n// Merge function to merge two halves\nvoid merge(std::vector<int>& arr, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    // Create temporary vectors\n    std::vector<int> L(n1);\n    std::vector<int> R(n2);\n\n    // Copy data to temp vectors L[] and R[]\n    for (int i = 0; i < n1; i++) L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n\n    // Merge the temp vectors back into arr[left..right]\n    int i = 0;\n    int j = 0;\n    int k = left;\n\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[], if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[], if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// Function to sort the array using merge sort\nvoid merge_sort(std::vector<int>& arr, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n\n        // Sort first and second halves\n        merge_sort(arr, left, mid);\n        merge_sort(arr, mid + 1, right);\n\n        // Merge the sorted halves\n        merge(arr, left, mid, right);\n    }\n}\n\nint main() {\n    std::vector<int> input_array = {4, 2, 5, 1, 3};\n    merge_sort(input_array, 0, input_array.size() - 1);\n    \n    for (int num : input_array) {\n        std::cout << num << \" \"; // Print the sorted array\n    }\n    std::cout << std::endl;\n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "import sys\n\n# Merge function to merge two halves\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n\n    # Create temporary vectors\n    L = arr[left:mid+1]\n    R = arr[mid+1:right+1]\n\n    # Merge the temp vectors back into arr[left..right]\n    i = 0\n    j = 0\n    k = left\n\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of L[], if there are any\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of R[], if there are any\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n\n# Function to sort the array using merge sort\n\ndef merge_sort(arr, left, right):\n    if left < right:\n        mid = (left + right) // 2\n\n        # Sort first and second halves\n        merge_sort(arr, left, mid)\n        merge_sort(arr, mid+1, right)\n\n        # Merge the sorted halves\n        merge(arr, left, mid, right)\n\n# Main function to test the merge sort algorithm\n\ndef main():\n    input_array = [4, 2, 5, 1, 3]\n    merge_sort(input_array, 0, len(input_array)-1)\n\n    for num in input_array:\n        print(num, end=\" \") # Print the sorted array\n    print()\n    return 0 # return 0 to indicate the program ended successfully",
        "expected_python_code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2  # Finding the mid of the array\n        left_half = arr[:mid]  # Dividing the elements into 2 halves\n        right_half = arr[mid:]\n\n        merge_sort(left_half)  # Sorting the first half\n        merge_sort(right_half)  # Sorting the second half\n\n        i = j = k = 0\n\n        # Copy data to temp arrays L[] and R[]\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        # Checking if any element was left\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n# Test the function with the input [4, 2, 5, 1, 3]\ninput_array = [4, 2, 5, 1, 3]\nmerge_sort(input_array)\nprint(input_array) # Output: [1, 2, 3, 4, 5]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "04 Linked List Implementation",
        "cpp_code": "#include <iostream> // include the iostream library for input and output\n\n// Define the Node structure\nstruct Node {\n    int data;\n    Node* next;\n    \n    Node(int data) : data(data), next(nullptr) {}\n};\n\n// Define the LinkedList class\nclass LinkedList {\npublic:\n    LinkedList() : head(nullptr) {}\n    \n    // Add a node with the given data to the front of the list\n    void add(int data) {\n        Node* new_node = new Node(data);\n        new_node->next = head;\n        head = new_node;\n    }\n    \n    // Remove the first node with the given data\n    void remove(int data) {\n        Node* current = head;\n        Node* previous = nullptr;\n        \n        while (current != nullptr) {\n            if (current->data == data) {\n                if (previous == nullptr) {\n                    head = current->next;\n                } else {\n                    previous->next = current->next;\n                }\n                delete current;\n                return;\n            }\n            previous = current;\n            current = current->next;\n        }\n    }\n    \n    // Print the linked list\n    void print() const {\n        Node* current = head;\n        std::cout << \"[\";\n        while (current != nullptr) {\n            std::cout << current->data;\n            if (current->next != nullptr) {\n                std::cout << \", \";\n            }\n            current = current->next;\n        }\n        std::cout << \"]\" << std::endl;\n    }\n    \n    ~LinkedList() {\n        Node* current = head;\n        while (current != nullptr) {\n            Node* next = current->next;\n            delete current;\n            current = next;\n        }\n    }\n    \nprivate:\n    Node* head;\n};\n\nint main() {\n    LinkedList linked_list;\n    linked_list.add(1);\n    linked_list.add(2);\n    linked_list.remove(1);\n    linked_list.print(); // Output: [2]\n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "# include <iostream> # include the iostream library for input and output\n\n# Define the Node structure\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n# Define the LinkedList class\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    # Add a node with the given data to the front of the list\n    def add(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    # Remove the first node with the given data\n    def remove(self, data):\n        current = self.head\n        previous = None\n\n        while current is not None:\n            if current.data == data:\n                if previous is None:\n                    self.head = current.next\n                else:\n                    previous.next = current.next\n                del current\n                return\n            previous = current\n            current = current.next\n\n    # Print the linked list\n    def print(self):\n        current = self.head\n        print(\"[\", end=\"\")\n        while current is not None:\n            print(current.data, end=\"\")\n            if current.next is not None:\n                print(\", \", end=\"\")\n            current = current.next\n        print(\"]\")\n\n# Main function\n\ndef main():\n    linked_list = LinkedList()\n    linked_list.add(1)\n    linked_list.add(2)\n    linked_list.remove(1)\n    linked_list.print() # Output: [2]\n    return 0 # return 0 to indicate the program ended successfully",
        "expected_python_code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def add(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n    \n    def remove(self, data):\n        current = self.head\n        previous = None\n        \n        while current is not None:\n            if current.data == data:\n                if previous is None:\n                    self.head = current.next\n                else:\n                    previous.next = current.next\n                return\n            previous = current\n            current = current.next\n    \n    def __str__(self):\n        elements = []\n        current = self.head\n        while current:\n            elements.append(current.data)\n            current = current.next\n        return str(elements)\n\n# Create a linked list and manipulate it according to the input\nlinked_list = LinkedList()\nlinked_list.add(1)\nlinked_list.add(2)\nlinked_list.remove(1)\nprint(linked_list) # Output: [2]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "05 Queue Using Two Stacks",
        "cpp_code": "#include <iostream> // include the iostream library for input and output\n#include <stack>    // include the stack library for std::stack\n\nclass QueueUsingTwoStacks {\npublic:\n    void enqueue(int item) {\n        // Push item onto stack1\n        stack1.push(item);\n    }\n    \n    int dequeue() {\n        if (stack2.empty()) {\n            // Transfer elements from stack1 to stack2, if stack2 is empty\n            while (!stack1.empty()) {\n                stack2.push(stack1.top());\n                stack1.pop();\n            }\n        }\n        if (!stack2.empty()) {\n            int item = stack2.top();\n            stack2.pop();\n            return item;\n        } else {\n            throw std::out_of_range(\"Dequeue from empty queue\");\n        }\n    }\n    \nprivate:\n    std::stack<int> stack1;\n    std::stack<int> stack2;\n};\n\nint main() {\n    QueueUsingTwoStacks queue;\n    queue.enqueue(1);\n    queue.enqueue(2);\n    try {\n        int dequeued_item = queue.dequeue();\n        std::cout << \"Dequeued: \" << dequeued_item << std::endl; // Output: Dequeued: 1\n    } catch (const std::out_of_range& e) {\n        std::cerr << e.what() << std::endl;\n    }\n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "import sys\nfrom collections import deque\n\nclass QueueUsingTwoStacks:\n    def __init__(self):\n        self.stack1 = deque()\n        self.stack2 = deque()\n\n    def enqueue(self, item):\n        self.stack1.append(item)\n\n    def dequeue(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        try:\n            return self.stack2.pop()\n        except IndexError:\n            raise ValueError(\"Dequeue from empty queue\")\n\nif __name__ == \"__main__\":\n    queue = QueueUsingTwoStacks()\n    queue.enqueue(1)\n    queue.enqueue(2)\n    try:\n        dequeued_item = queue.dequeue()\n        print(\"Dequeued:\", dequeued_item) # Output: Dequeued: 1\n    except ValueError as e:\n        print(e)",
        "expected_python_code": "class QueueUsingTwoStacks:\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def enqueue(self, item):\n        # Push item onto stack1\n        self.stack1.append(item)\n    \n    def dequeue(self):\n        if not self.stack2:\n            # Transfer elements from stack1 to stack2, if stack2 is empty\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            raise IndexError(\"Dequeue from empty queue\")\n\n# Create a queue and manipulate it according to the input\nqueue = QueueUsingTwoStacks()\nqueue.enqueue(1)\nqueue.enqueue(2)\ndequeued_item = queue.dequeue()\nprint(f\"Dequeued: {dequeued_item}\") # Output: Dequeued: 1",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "06 Balanced Parentheses",
        "cpp_code": "#include <iostream> // include the iostream library for input and output\n#include <stack>    // include the stack library for std::stack\n#include <unordered_map> // include the unordered_map library for std::unordered_map\n\nbool is_balanced(const std::string& s) {\n    std::stack<char> stack;\n    std::unordered_map<char, char> matching_parenthesis = {\n        {')', '('},\n        {'}', '{'},\n        {']', '['}\n    };\n    \n    for (char char : s) {\n        if (matching_parenthesis.count(char)) {\n            // If it's a closing bracket, check for matching opening bracket\n            if (stack.empty() || stack.top() != matching_parenthesis[char]) {\n                return false;\n            }\n            stack.pop();\n        } else if (char == '(' || char == '{' || char == '[') {\n            // If it's an opening bracket, push it onto the stack\n            stack.push(char);\n        } else {\n            // If it's not a parenthesis, ignore\n            continue;\n        }\n    }\n    \n    // If stack is empty, all parentheses were matched\n    return stack.empty();\n}\n\nint main() {\n    std::string input_string = \"((()))\";\n    std::cout << (is_balanced(input_string) ? \"True\" : \"False\") << std::endl; // Output: True\n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "import sys\nfrom collections import deque\n\ndef is_balanced(s):\n    stack = deque()\n    matching_parenthesis = {')': '(', '}': '{', ']': '['}\n\n    for char in s:\n        if char in matching_parenthesis:\n            # If it's a closing bracket, check for matching opening bracket\n            if not stack or stack[-1] != matching_parenthesis[char]:\n                return False\n            stack.pop()\n        elif char in ['(', '{', '[']:\n            # If it's an opening bracket, push it onto the stack\n            stack.append(char)\n        else:\n            # If it's not a parenthesis, ignore\n            continue\n\n    # If stack is empty, all parentheses were matched\n    return not stack\n\nif __name__ == \"__main__\":\n    input_string = \"((()))\"\n    print(is_balanced(input_string))  # Output: True",
        "expected_python_code": "def is_balanced(s):\n    stack = []\n    # Dictionary to hold matching pairs\n    matching_parenthesis = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in matching_parenthesis.values():\n            # If it's an opening bracket, push it onto the stack\n            stack.append(char)\n        elif char in matching_parenthesis.keys():\n            # If it's a closing bracket, check for matching opening bracket\n            if stack == [] or matching_parenthesis[char] != stack.pop():\n                return False\n        else:\n            # If it's not a parenthesis, ignore\n            continue\n    \n    # If stack is empty, all parentheses were matched\n    return stack == []\n\n# Test the function with the input \"((()))\"\ninput_string = \"((()))\"\nprint(is_balanced(input_string))  # Output: True",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "07 Longest Substring Without Repeating Characters",
        "cpp_code": "#include <iostream>       // include the iostream library for input and output\n#include <unordered_map> // include the unordered_map library for std::unordered_map\n#include <string>         // include the string library for std::string\n\nstd::string longest_substring_without_repeating(const std::string& s) {\n    std::unordered_map<char, int> char_index; // Dictionary to store the last index of each character\n    int start = 0; // Start index of the current substring\n    int max_length = 0; // Maximum length of substring without repeating characters\n    std::string longest_substr; // The longest substring without repeating characters\n    \n    for (int end = 0; end < s.length(); ++end) {\n        char char_end = s[end];\n        \n        if (char_index.count(char_end) && char_index[char_end] >= start) {\n            // Move the start index to one past the last occurrence of the current character\n            start = char_index[char_end] + 1;\n        }\n        \n        char_index[char_end] = end; // Update the last index of the current character\n        \n        int current_length = end - start + 1; // Calculate current substring length\n        \n        if (current_length > max_length) {\n            max_length = current_length;\n            longest_substr = s.substr(start, current_length);\n        }\n    }\n    \n    return longest_substr;\n}\n\nint main() {\n    std::string input_string = \"abcabcbb\";\n    std::cout << longest_substring_without_repeating(input_string) << std::endl; // Output: \"abc\"\n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "import string\n\ndef longest_substring_without_repeating(s):\n    char_index = {}\n    start = 0\n    max_length = 0\n    longest_substr = \"\"\n\n    for end in range(len(s)):\n        char_end = s[end]\n\n        if char_end in char_index and char_index[char_end] >= start:\n            start = char_index[char_end] + 1\n\n        char_index[char_end] = end\n\n        current_length = end - start + 1\n\n        if current_length > max_length:\n            max_length = current_length\n            longest_substr = s[start:end+1]\n\n    return longest_substr\n\nif __name__ == \"__main__\":\n    input_string = \"abcabcbb\"\n    print(longest_substring_without_repeating(input_string)) # Output: \"abc\"",
        "expected_python_code": "def longest_substring_without_repeating(s):\n    char_index = {}  # Dictionary to store the last index of each character\n    start = 0  # Start index of the current substring\n    max_length = 0  # Maximum length of substring without repeating characters\n    longest_substr = \"\"  # The longest substring without repeating characters\n    \n    for end, char in enumerate(s):\n        if char in char_index and char_index[char] >= start:\n            # Move the start index to one past the last occurrence of the current character\n            start = char_index[char] + 1\n        \n        char_index[char] = end  # Update the last index of the current character\n        current_length = end - start + 1  # Calculate current substring length\n        \n        if current_length > max_length:\n            max_length = current_length\n            longest_substr = s[start:end + 1]\n    \n    return longest_substr\n\n# Test the function with the input \"abcabcbb\"\ninput_string = \"abcabcbb\"\nprint(longest_substring_without_repeating(input_string))  # Output: \"abc\"",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "08 Sum of Digits",
        "cpp_code": "#include <iostream> // include the iostream library for input and output\n\nint sum_of_digits(int n) {\n    // This function calculates the sum of digits of a number until a single digit is obtained\n    while (n >= 10) { // Continue until n is a single digit\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10; // Add the last digit to sum\n            n /= 10;       // Remove the last digit from n\n        }\n        n = sum; // Update n to the new sum\n    }\n    return n;\n}\n\nint main() {\n    int input_number = 38;\n    std::cout << sum_of_digits(input_number) << std::endl; // Output: 2\n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "import sys\n\ndef sum_of_digits(n):\n    # This function calculates the sum of digits of a number until a single digit is obtained\n    while n >= 10: # Continue until n is a single digit\n        sum = 0\n        while n > 0:\n            sum += n % 10 # Add the last digit to sum\n            n //= 10       # Remove the last digit from n\n        n = sum # Update n to the new sum\n    return n\n\ndef main():\n    input_number = 38\n    print(sum_of_digits(input_number)) # Output: 2\n    return 0 # return 0 to indicate the program ended successfully",
        "expected_python_code": "def sum_of_digits(n):\n    # This function calculates the sum of digits of a number until a single digit is obtained\n    while n >= 10:  # Continue until n is a single digit\n        n = sum(int(digit) for digit in str(n))  # Sum of digits\n    return n\n\n# Test the function with the input 38\ninput_number = 38\nprint(sum_of_digits(input_number))  # Output: 2",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "09 Find Duplicates in Array",
        "cpp_code": "#include <iostream>       // include the iostream library for input and output\n#include <unordered_set> // include the unordered_set library for std::unordered_set\n#include <vector>         // include the vector library for std::vector\n\nstd::vector<int> find_duplicates(const std::vector<int>& arr) {\n    std::unordered_set<int> seen;      // Set to keep track of seen elements\n    std::unordered_set<int> duplicates; // Set to keep track of duplicates\n\n    for (int num : arr) {\n        if (seen.find(num) != seen.end()) {\n            // If the number is already in 'seen', it's a duplicate\n            duplicates.insert(num);\n        } else {\n            // Otherwise, add it to 'seen'\n            seen.insert(num);\n        }\n    }\n\n    // Convert duplicates set to vector and return\n    return std::vector<int>(duplicates.begin(), duplicates.end());\n}\n\nint main() {\n    std::vector<int> input_array = {1, 2, 3, 1, 4, 2};\n    std::vector<int> result = find_duplicates(input_array);\n    \n    std::cout << \"Duplicates: \";\n    for (int num : result) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl; // Output: Duplicates: 1 2\n    \n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "import collections\n\ndef find_duplicates(arr):\n    seen = set()\n    duplicates = set()\n\n    for num in arr:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n\n    return list(duplicates)\n\nif __name__ == \"__main__\":\n    input_array = [1, 2, 3, 1, 4, 2]\n    result = find_duplicates(input_array)\n\n    print(\"Duplicates:\")\n    for num in result:\n        print(num, end=\" \")",
        "expected_python_code": "def find_duplicates(arr):\n    seen = set()\n    duplicates = set()\n    \n    for num in arr:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n    \n    return list(duplicates)\n\n# Test the function with the input [1, 2, 3, 1, 4, 2]\ninput_array = [1, 2, 3, 1, 4, 2]\nprint(find_duplicates(input_array))  # Output: [1, 2]",
        "match_with_reference": false,
        "success": true,
        "error": null
    },
    {
        "title": "10 Rotate Matrix",
        "cpp_code": "#include <iostream>         // include the iostream library for input and output\n#include <vector>           // include the vector library for std::vector\n\nvoid rotate_matrix(std::vector<std::vector<int>>& matrix) {\n    int n = matrix.size(); // Get the number of rows (assuming square matrix)\n\n    // Transpose the matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            std::swap(matrix[i][j], matrix[j][i]);\n        }\n    }\n\n    // Reverse each row\n    for (int i = 0; i < n; ++i) {\n        std::reverse(matrix[i].begin(), matrix[i].end());\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> input_matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n    \n    rotate_matrix(input_matrix);\n    \n    std::cout << \"Rotated matrix:\" << std::endl;\n    for (const auto& row : input_matrix) {\n        for (int num : row) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    \n    return 0; // return 0 to indicate the program ended successfully\n}",
        "translated_python_code": "# include <iostream>         # include the iostream library for input and output\n# include <vector>           # include the vector library for std::vector\n\ndef rotate_matrix(matrix):\n    n = len(matrix)  # Get the number of rows (assuming square matrix)\n\n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    # Reverse each row\n    for i in range(n):\n        matrix[i].reverse()\n\n# main function\n\ndef main():\n    input_matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    rotate_matrix(input_matrix)\n\n    print(\"Rotated matrix:\")\n    for row in input_matrix:\n        for num in row:\n            print(num, end=\" \")\n        print()\n\n    return 0 # return 0 to indicate the program ended successfully",
        "expected_python_code": "def rotate_matrix(matrix):\n    # Transpose the matrix\n    transposed = list(zip(*matrix))\n    \n    # Reverse each row of the transposed matrix\n    rotated = [list(row)[::-1] for row in transposed]\n    \n    return rotated\n\n# Test the function with the input [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ninput_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(rotate_matrix(input_matrix))  # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]",
        "match_with_reference": false,
        "success": true,
        "error": null
    }
]